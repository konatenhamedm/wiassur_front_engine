{"version":3,"file":"index-C1KguBil.js","sources":["../src/resolvers/index.ts"],"sourcesContent":["import type {ComponentResolver} from 'unplugin-vue-components'\nimport {\n  componentNames,\n  componentsWithExternalPath,\n  type ComponentType,\n  type ConfigurationOption,\n  directiveNames,\n  directivesWithExternalPath,\n  type DirectiveType,\n} from '../types/BootstrapVueOptions'\n\nconst bvKey = 'bootstrap-vue-next'\n\nconst parseActiveImports = <Type extends string, Base extends ConfigurationOption<Type>>(\n  options: Readonly<Base>,\n  values: readonly Type[]\n): Type[] => {\n  const {all, ...others} = options\n  const valuesCopy: Partial<Record<keyof Base, boolean>> = {}\n  if (all) {\n    values.forEach((el) => {\n      valuesCopy[el] = all\n    })\n  }\n  const merge: Record<string, boolean> = {...valuesCopy, ...others}\n  return (\n    Object.entries(merge)\n      // filtering possible invalid keys\n      .filter(([name, value]) => !!value && values.includes(name as Type))\n      .map(([name]) => name as Type)\n  )\n}\n\nconst usedComponents = new Set<string>()\nconst usedDirectives = new Set<string>()\n\n/**\n * Resolver for unplugin-vue-components\n *\n * Contains two hidden properties `__usedComponents` and `__usedDirectives` (both are `Set<string>`)\n * which are used to get the list of used components and directives.. You can use this list of used components.\n * It may not be fully accurate. It can be used to get a list of stuff to trim down, like css\n * @example\n * ```ts\n * const bootstrapVueNextResolver = BootstrapVueNextResolver()\n * console.info(bootstrapVueNextResolver.__usedComponents)\n * console.info(bootstrapVueNextResolver.__usedDirectives)\n *\n * // ... blah blah blah, `plugins: [Components({resolvers: [bootstrapVueNextResolver]})]` ...\n * ```\n */\nexport const BootstrapVueNextResolver = Object.assign(\n  ({\n    aliases = {},\n    directives = true,\n    components = true,\n  }: Readonly<{\n    components?: boolean | ConfigurationOption<ComponentType>\n    directives?: boolean | ConfigurationOption<DirectiveType>\n    aliases?: Record<string, ComponentType>\n  }> = {}): ComponentResolver[] => {\n    const selectedComponents = typeof components === 'boolean' ? {all: components} : components\n    // <ComponentType, ImportPath>\n    const compImports = parseActiveImports(selectedComponents, componentNames).reduce(\n      (map, name) => {\n        map.set(name, `${bvKey}${componentsWithExternalPath[name]}`)\n        return map\n      },\n      new Map<string, string>()\n    )\n\n    const selectedDirectives = typeof directives === 'boolean' ? {all: directives} : directives\n    // <DirectiveType, ImportPath>\n    const dirImports = parseActiveImports(selectedDirectives, directiveNames).reduce(\n      (map, directive) => {\n        const key = (\n          directive.toLowerCase().startsWith('v') ? directive : `v${directive}`\n        ) as DirectiveType\n        map.set(key, `${bvKey}${directivesWithExternalPath[key]}`)\n        return map\n      },\n      new Map<string, string>()\n    )\n\n    const resolvers: ComponentResolver[] = [\n      {\n        type: 'component',\n        resolve(name) {\n          const destination = compImports.get(name)\n          const aliasDestination = compImports.get(aliases[name])\n          if (aliasDestination) {\n            const val = aliases[name]\n            usedComponents.add(val)\n            return {\n              name: val,\n              from: aliasDestination,\n            }\n          }\n\n          if (destination) {\n            usedComponents.add(name)\n            return {\n              name,\n              from: destination,\n            }\n          }\n        },\n      },\n      {\n        type: 'directive',\n        resolve(name) {\n          const prefixedName = `v${name}`\n          const destination = dirImports.get(prefixedName)\n          if (destination) {\n            usedDirectives.add(prefixedName)\n            return {\n              name: prefixedName,\n              from: destination,\n            }\n          }\n        },\n      },\n    ]\n    return resolvers\n  },\n  {\n    __usedComponents: usedComponents,\n    __usedDirectives: usedDirectives,\n  }\n)\n"],"names":["bvKey","parseActiveImports","options","values","all","others","valuesCopy","forEach","el","merge","Object","entries","filter","name","value","includes","map","usedComponents","Set","usedDirectives","BootstrapVueNextResolver","assign","aliases","directives","components","compImports","componentNames","reduce","set","componentsWithExternalPath","Map","dirImports","directiveNames","directive","key","toLowerCase","startsWith","directivesWithExternalPath","type","resolve","destination","get","aliasDestination","val","add","from","prefixedName","__usedComponents","__usedDirectives"],"mappings":"kEAWMA,EAAQ,qBAERC,EAAqB,CACzBC,EACAC,KAEA,MAAMC,IAACA,KAAQC,GAAUH,EACnBI,EAAmD,CAAA,EACrDF,GACFD,EAAOI,QAASC,IACdF,EAAWE,GAAMJ,IAGrB,MAAMK,EAAiC,IAAIH,KAAeD,GAC1D,OACEK,OAAOC,QAAQF,GAEZG,OAAO,EAAEC,EAAMC,OAAaA,GAASX,EAAOY,SAASF,IACrDG,IAAI,EAAEH,KAAUA,IAIjBI,MAAqBC,IACrBC,MAAqBD,IAiBdE,EAA2BV,OAAOW,OAC7C,EACEC,UAAU,CAAA,EACVC,cAAa,EACbC,cAAa,GAKV,MACH,MAEMC,EAAcxB,EAF6B,kBAAfuB,EAA2B,CAACpB,IAAKoB,GAAcA,EAEtBE,EAAAA,gBAAgBC,OACzE,CAACX,EAAKH,KACJG,EAAIY,IAAIf,EAAM,GAAGb,IAAQ6B,EAAAA,2BAA2BhB,MAC7CG,OAELc,KAKAC,EAAa9B,EAF8B,kBAAfsB,EAA2B,CAACnB,IAAKmB,GAAcA,EAEvBS,EAAAA,gBAAgBL,OACxE,CAACX,EAAKiB,KACJ,MAAMC,EACJD,EAAUE,cAAcC,WAAW,KAAOH,EAAY,IAAIA,IAG5D,OADAjB,EAAIY,IAAIM,EAAK,GAAGlC,IAAQqC,EAAAA,2BAA2BH,MAC5ClB,OAELc,KA0CN,MAvCuC,CACrC,CACEQ,KAAM,YACN,OAAAC,CAAQ1B,GACN,MAAM2B,EAAcf,EAAYgB,IAAI5B,GAC9B6B,EAAmBjB,EAAYgB,IAAInB,EAAQT,IACjD,GAAI6B,EAAkB,CACpB,MAAMC,EAAMrB,EAAQT,GAEpB,OADAI,EAAe2B,IAAID,GACZ,CACL9B,KAAM8B,EACNE,KAAMH,EAEV,CAEA,GAAIF,EAEF,OADAvB,EAAe2B,IAAI/B,GACZ,CACLA,OACAgC,KAAML,EAGZ,GAEF,CACEF,KAAM,YACN,OAAAC,CAAQ1B,GACN,MAAMiC,EAAe,IAAIjC,IACnB2B,EAAcT,EAAWU,IAAIK,GACnC,GAAIN,EAEF,OADArB,EAAeyB,IAAIE,GACZ,CACLjC,KAAMiC,EACND,KAAML,EAGZ,KAKN,CACEO,iBAAkB9B,EAClB+B,iBAAkB7B"}