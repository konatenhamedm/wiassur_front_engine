{"version":3,"file":"index-BSgsF2PB.mjs","sources":["../src/resolvers/index.ts"],"sourcesContent":["import type {ComponentResolver} from 'unplugin-vue-components'\nimport {\n  componentNames,\n  componentsWithExternalPath,\n  type ComponentType,\n  type ConfigurationOption,\n  directiveNames,\n  directivesWithExternalPath,\n  type DirectiveType,\n} from '../types/BootstrapVueOptions'\n\nconst bvKey = 'bootstrap-vue-next'\n\nconst parseActiveImports = <Type extends string, Base extends ConfigurationOption<Type>>(\n  options: Readonly<Base>,\n  values: readonly Type[]\n): Type[] => {\n  const {all, ...others} = options\n  const valuesCopy: Partial<Record<keyof Base, boolean>> = {}\n  if (all) {\n    values.forEach((el) => {\n      valuesCopy[el] = all\n    })\n  }\n  const merge: Record<string, boolean> = {...valuesCopy, ...others}\n  return (\n    Object.entries(merge)\n      // filtering possible invalid keys\n      .filter(([name, value]) => !!value && values.includes(name as Type))\n      .map(([name]) => name as Type)\n  )\n}\n\nconst usedComponents = new Set<string>()\nconst usedDirectives = new Set<string>()\n\n/**\n * Resolver for unplugin-vue-components\n *\n * Contains two hidden properties `__usedComponents` and `__usedDirectives` (both are `Set<string>`)\n * which are used to get the list of used components and directives.. You can use this list of used components.\n * It may not be fully accurate. It can be used to get a list of stuff to trim down, like css\n * @example\n * ```ts\n * const bootstrapVueNextResolver = BootstrapVueNextResolver()\n * console.info(bootstrapVueNextResolver.__usedComponents)\n * console.info(bootstrapVueNextResolver.__usedDirectives)\n *\n * // ... blah blah blah, `plugins: [Components({resolvers: [bootstrapVueNextResolver]})]` ...\n * ```\n */\nexport const BootstrapVueNextResolver = Object.assign(\n  ({\n    aliases = {},\n    directives = true,\n    components = true,\n  }: Readonly<{\n    components?: boolean | ConfigurationOption<ComponentType>\n    directives?: boolean | ConfigurationOption<DirectiveType>\n    aliases?: Record<string, ComponentType>\n  }> = {}): ComponentResolver[] => {\n    const selectedComponents = typeof components === 'boolean' ? {all: components} : components\n    // <ComponentType, ImportPath>\n    const compImports = parseActiveImports(selectedComponents, componentNames).reduce(\n      (map, name) => {\n        map.set(name, `${bvKey}${componentsWithExternalPath[name]}`)\n        return map\n      },\n      new Map<string, string>()\n    )\n\n    const selectedDirectives = typeof directives === 'boolean' ? {all: directives} : directives\n    // <DirectiveType, ImportPath>\n    const dirImports = parseActiveImports(selectedDirectives, directiveNames).reduce(\n      (map, directive) => {\n        const key = (\n          directive.toLowerCase().startsWith('v') ? directive : `v${directive}`\n        ) as DirectiveType\n        map.set(key, `${bvKey}${directivesWithExternalPath[key]}`)\n        return map\n      },\n      new Map<string, string>()\n    )\n\n    const resolvers: ComponentResolver[] = [\n      {\n        type: 'component',\n        resolve(name) {\n          const destination = compImports.get(name)\n          const aliasDestination = compImports.get(aliases[name])\n          if (aliasDestination) {\n            const val = aliases[name]\n            usedComponents.add(val)\n            return {\n              name: val,\n              from: aliasDestination,\n            }\n          }\n\n          if (destination) {\n            usedComponents.add(name)\n            return {\n              name,\n              from: destination,\n            }\n          }\n        },\n      },\n      {\n        type: 'directive',\n        resolve(name) {\n          const prefixedName = `v${name}`\n          const destination = dirImports.get(prefixedName)\n          if (destination) {\n            usedDirectives.add(prefixedName)\n            return {\n              name: prefixedName,\n              from: destination,\n            }\n          }\n        },\n      },\n    ]\n    return resolvers\n  },\n  {\n    __usedComponents: usedComponents,\n    __usedDirectives: usedDirectives,\n  }\n)\n"],"names":[],"mappings":";AAWA,MAAM,QAAQ;AAEd,MAAM,qBAAqB,CACzB,SACA,WACW;AACX,QAAM,EAAC,KAAK,GAAG,OAAA,IAAU;AACzB,QAAM,aAAmD,CAAA;AACzD,MAAI,KAAK;AACP,WAAO,QAAQ,CAAC,OAAO;AACrB,iBAAW,EAAE,IAAI;AAAA,IACnB,CAAC;AAAA,EACH;AACA,QAAM,QAAiC,EAAC,GAAG,YAAY,GAAG,OAAA;AAC1D,SACE,OAAO,QAAQ,KAAK,EAEjB,OAAO,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC,CAAC,SAAS,OAAO,SAAS,IAAY,CAAC,EAClE,IAAI,CAAC,CAAC,IAAI,MAAM,IAAY;AAEnC;AAEA,MAAM,qCAAqB,IAAA;AAC3B,MAAM,qCAAqB,IAAA;AAiBpB,MAAM,2BAA2B,OAAO;AAAA,EAC7C,CAAC;AAAA,IACC,UAAU,CAAA;AAAA,IACV,aAAa;AAAA,IACb,aAAa;AAAA,EAAA,IAKV,OAA4B;AAC/B,UAAM,qBAAqB,OAAO,eAAe,YAAY,EAAC,KAAK,eAAc;AAEjF,UAAM,cAAc,mBAAmB,oBAAoB,cAAc,EAAE;AAAA,MACzE,CAAC,KAAK,SAAS;AACb,YAAI,IAAI,MAAM,GAAG,KAAK,GAAG,2BAA2B,IAAI,CAAC,EAAE;AAC3D,eAAO;AAAA,MACT;AAAA,0BACI,IAAA;AAAA,IAAoB;AAG1B,UAAM,qBAAqB,OAAO,eAAe,YAAY,EAAC,KAAK,eAAc;AAEjF,UAAM,aAAa,mBAAmB,oBAAoB,cAAc,EAAE;AAAA,MACxE,CAAC,KAAK,cAAc;AAClB,cAAM,MACJ,UAAU,YAAA,EAAc,WAAW,GAAG,IAAI,YAAY,IAAI,SAAS;AAErE,YAAI,IAAI,KAAK,GAAG,KAAK,GAAG,2BAA2B,GAAG,CAAC,EAAE;AACzD,eAAO;AAAA,MACT;AAAA,0BACI,IAAA;AAAA,IAAoB;AAG1B,UAAM,YAAiC;AAAA,MACrC;AAAA,QACE,MAAM;AAAA,QACN,QAAQ,MAAM;AACZ,gBAAM,cAAc,YAAY,IAAI,IAAI;AACxC,gBAAM,mBAAmB,YAAY,IAAI,QAAQ,IAAI,CAAC;AACtD,cAAI,kBAAkB;AACpB,kBAAM,MAAM,QAAQ,IAAI;AACxB,2BAAe,IAAI,GAAG;AACtB,mBAAO;AAAA,cACL,MAAM;AAAA,cACN,MAAM;AAAA,YAAA;AAAA,UAEV;AAEA,cAAI,aAAa;AACf,2BAAe,IAAI,IAAI;AACvB,mBAAO;AAAA,cACL;AAAA,cACA,MAAM;AAAA,YAAA;AAAA,UAEV;AAAA,QACF;AAAA,MAAA;AAAA,MAEF;AAAA,QACE,MAAM;AAAA,QACN,QAAQ,MAAM;AACZ,gBAAM,eAAe,IAAI,IAAI;AAC7B,gBAAM,cAAc,WAAW,IAAI,YAAY;AAC/C,cAAI,aAAa;AACf,2BAAe,IAAI,YAAY;AAC/B,mBAAO;AAAA,cACL,MAAM;AAAA,cACN,MAAM;AAAA,YAAA;AAAA,UAEV;AAAA,QACF;AAAA,MAAA;AAAA,IACF;AAEF,WAAO;AAAA,EACT;AAAA,EACA;AAAA,IACE,kBAAkB;AAAA,IAClB,kBAAkB;AAAA,EAAA;AAEtB;;;;;"}