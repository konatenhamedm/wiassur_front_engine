{"version":3,"file":"index.umd.js","sources":["../../../../src/composables/useProvideDefaults/index.ts"],"sourcesContent":["import {computed, inject, provide, type Ref, unref} from 'vue'\nimport {defaultsKey} from '../../utils/keys'\nimport type {BvnComponentProps} from '../../types/BootstrapVueOptions'\nimport type {BAppProps} from '../../types/ComponentProps'\n\nexport const useProvideDefaults = (\n  defaults: BAppProps['defaults'] | Ref<BAppProps['defaults']>,\n  mergeDefaults: BAppProps['mergeDefaults']\n) => {\n  // Inject existing defaults from parent (could be from plugins)\n  const injectedDefaults = inject(defaultsKey, undefined)\n\n  // Merge injected defaults with prop defaults (prop takes priority)\n  const mergedDefaults = computed<Partial<BvnComponentProps>>(() => {\n    const _defaults = unref(defaults)\n    if (!injectedDefaults) {\n      return _defaults ?? {}\n    }\n    const merged = {...injectedDefaults.value} as Partial<BvnComponentProps>\n\n    if (_defaults) {\n      // If mergeDefaults is a function, call it with\n      if (mergeDefaults) {\n        if (typeof mergeDefaults === 'function') {\n          return mergeDefaults(merged, _defaults) as Partial<BvnComponentProps>\n        } else if (mergeDefaults === true) {\n          return deepMerge(merged, _defaults)\n        }\n        return Object.assign(merged, _defaults)\n      }\n      return _defaults\n    }\n\n    return merged\n  })\n\n  // Provide the merged defaults to child components\n  provide(defaultsKey, mergedDefaults)\n}\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    value.constructor === Object &&\n    Object.prototype.toString.call(value) === '[object Object]'\n  )\n}\n\nfunction deepMerge<T extends Record<string, unknown>, S extends Record<string, unknown>>(\n  target: T,\n  source: S,\n  visited = new WeakSet()\n): T & S {\n  // Handle circular references\n  if (visited.has(source)) {\n    return target as T & S\n  }\n  visited.add(source)\n\n  // Create a new object to avoid mutating the target\n  const result: Record<string, unknown> = {...target}\n\n  for (const key in source) {\n    const sourceValue = source[key]\n    const targetValue = target[key]\n\n    if (isPlainObject(sourceValue) && isPlainObject(targetValue)) {\n      // Recursively merge plain objects\n      result[key] = deepMerge(\n        targetValue as Record<string, unknown>,\n        sourceValue as Record<string, unknown>,\n        visited\n      )\n    } else if (Array.isArray(sourceValue)) {\n      // Copy arrays to avoid mutation\n      result[key] = [...sourceValue]\n    } else {\n      // Replace value for all other types (primitives, class instances, Vue refs, etc.)\n      result[key] = sourceValue\n    }\n  }\n\n  return result as T & S\n}\n"],"names":["isPlainObject","value","constructor","Object","prototype","toString","call","deepMerge","target","source","visited","WeakSet","has","add","result","key","sourceValue","targetValue","Array","isArray","defaults","mergeDefaults","injectedDefaults","inject","defaultsKey","mergedDefaults","computed","_defaults","unref","merged","assign","provide"],"mappings":"8IAwCA,SAASA,EAAcC,GACrB,OACY,OAAVA,GACiB,iBAAVA,GACPA,EAAMC,cAAgBC,QACoB,oBAA1CA,OAAOC,UAAUC,SAASC,KAAKL,EAEnC,CAEA,SAASM,EACPC,EACAC,EACAC,EAAU,IAAIC,SAGd,GAAID,EAAQE,IAAIH,GACd,OAAOD,EAETE,EAAQG,IAAIJ,GAGZ,MAAMK,EAAkC,IAAIN,GAE5C,IAAA,MAAWO,KAAON,EAAQ,CACxB,MAAMO,EAAcP,EAAOM,GACrBE,EAAcT,EAAOO,GAEvBf,EAAcgB,IAAgBhB,EAAciB,GAE9CH,EAAOC,GAAOR,EACZU,EACAD,EACAN,GAEOQ,MAAMC,QAAQH,GAEvBF,EAAOC,GAAO,IAAIC,GAGlBF,EAAOC,GAAOC,CAElB,CAEA,OAAOF,CACT,4BA/EkC,CAChCM,EACAC,KAGA,MAAMC,EAAmBC,EAAAA,OAAOC,EAAAA,iBAAa,GAGvCC,EAAiBC,EAAAA,SAAqC,KAC1D,MAAMC,EAAYC,EAAAA,MAAMR,GACxB,IAAKE,EACH,OAAOK,GAAa,CAAA,EAEtB,MAAME,EAAS,IAAIP,EAAiBrB,OAEpC,OAAI0B,EAEEN,EAC2B,mBAAlBA,EACFA,EAAcQ,EAAQF,IACF,IAAlBN,EACFd,EAAUsB,EAAQF,GAEpBxB,OAAO2B,OAAOD,EAAQF,GAExBA,EAGFE,IAITE,EAAAA,QAAQP,EAAAA,YAAaC"}