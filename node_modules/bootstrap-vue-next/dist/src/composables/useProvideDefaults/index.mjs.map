{"version":3,"file":"index.mjs","sources":["../../../../src/composables/useProvideDefaults/index.ts"],"sourcesContent":["import {computed, inject, provide, type Ref, unref} from 'vue'\nimport {defaultsKey} from '../../utils/keys'\nimport type {BvnComponentProps} from '../../types/BootstrapVueOptions'\nimport type {BAppProps} from '../../types/ComponentProps'\n\nexport const useProvideDefaults = (\n  defaults: BAppProps['defaults'] | Ref<BAppProps['defaults']>,\n  mergeDefaults: BAppProps['mergeDefaults']\n) => {\n  // Inject existing defaults from parent (could be from plugins)\n  const injectedDefaults = inject(defaultsKey, undefined)\n\n  // Merge injected defaults with prop defaults (prop takes priority)\n  const mergedDefaults = computed<Partial<BvnComponentProps>>(() => {\n    const _defaults = unref(defaults)\n    if (!injectedDefaults) {\n      return _defaults ?? {}\n    }\n    const merged = {...injectedDefaults.value} as Partial<BvnComponentProps>\n\n    if (_defaults) {\n      // If mergeDefaults is a function, call it with\n      if (mergeDefaults) {\n        if (typeof mergeDefaults === 'function') {\n          return mergeDefaults(merged, _defaults) as Partial<BvnComponentProps>\n        } else if (mergeDefaults === true) {\n          return deepMerge(merged, _defaults)\n        }\n        return Object.assign(merged, _defaults)\n      }\n      return _defaults\n    }\n\n    return merged\n  })\n\n  // Provide the merged defaults to child components\n  provide(defaultsKey, mergedDefaults)\n}\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    value.constructor === Object &&\n    Object.prototype.toString.call(value) === '[object Object]'\n  )\n}\n\nfunction deepMerge<T extends Record<string, unknown>, S extends Record<string, unknown>>(\n  target: T,\n  source: S,\n  visited = new WeakSet()\n): T & S {\n  // Handle circular references\n  if (visited.has(source)) {\n    return target as T & S\n  }\n  visited.add(source)\n\n  // Create a new object to avoid mutating the target\n  const result: Record<string, unknown> = {...target}\n\n  for (const key in source) {\n    const sourceValue = source[key]\n    const targetValue = target[key]\n\n    if (isPlainObject(sourceValue) && isPlainObject(targetValue)) {\n      // Recursively merge plain objects\n      result[key] = deepMerge(\n        targetValue as Record<string, unknown>,\n        sourceValue as Record<string, unknown>,\n        visited\n      )\n    } else if (Array.isArray(sourceValue)) {\n      // Copy arrays to avoid mutation\n      result[key] = [...sourceValue]\n    } else {\n      // Replace value for all other types (primitives, class instances, Vue refs, etc.)\n      result[key] = sourceValue\n    }\n  }\n\n  return result as T & S\n}\n"],"names":[],"mappings":";;AAKO,MAAM,qBAAqB,CAChC,UACA,kBACG;AAEH,QAAM,mBAAmB,OAAO,aAAa,MAAS;AAGtD,QAAM,iBAAiB,SAAqC,MAAM;AAChE,UAAM,YAAY,MAAM,QAAQ;AAChC,QAAI,CAAC,kBAAkB;AACrB,aAAO,aAAa,CAAA;AAAA,IACtB;AACA,UAAM,SAAS,EAAC,GAAG,iBAAiB,MAAA;AAEpC,QAAI,WAAW;AAEb,UAAI,eAAe;AACjB,YAAI,OAAO,kBAAkB,YAAY;AACvC,iBAAO,cAAc,QAAQ,SAAS;AAAA,QACxC,WAAW,kBAAkB,MAAM;AACjC,iBAAO,UAAU,QAAQ,SAAS;AAAA,QACpC;AACA,eAAO,OAAO,OAAO,QAAQ,SAAS;AAAA,MACxC;AACA,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT,CAAC;AAGD,UAAQ,aAAa,cAAc;AACrC;AAEA,SAAS,cAAc,OAAkD;AACvE,SACE,UAAU,QACV,OAAO,UAAU,YACjB,MAAM,gBAAgB,UACtB,OAAO,UAAU,SAAS,KAAK,KAAK,MAAM;AAE9C;AAEA,SAAS,UACP,QACA,QACA,UAAU,oBAAI,WACP;AAEP,MAAI,QAAQ,IAAI,MAAM,GAAG;AACvB,WAAO;AAAA,EACT;AACA,UAAQ,IAAI,MAAM;AAGlB,QAAM,SAAkC,EAAC,GAAG,OAAA;AAE5C,aAAW,OAAO,QAAQ;AACxB,UAAM,cAAc,OAAO,GAAG;AAC9B,UAAM,cAAc,OAAO,GAAG;AAE9B,QAAI,cAAc,WAAW,KAAK,cAAc,WAAW,GAAG;AAE5D,aAAO,GAAG,IAAI;AAAA,QACZ;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,IAEJ,WAAW,MAAM,QAAQ,WAAW,GAAG;AAErC,aAAO,GAAG,IAAI,CAAC,GAAG,WAAW;AAAA,IAC/B,OAAO;AAEL,aAAO,GAAG,IAAI;AAAA,IAChB;AAAA,EACF;AAEA,SAAO;AACT;"}