{"version":3,"file":"index.umd.js","sources":["../../../../src/composables/useScrollspy/index.ts"],"sourcesContent":["import {syncRef, useIntersectionObserver, useMutationObserver} from '@vueuse/core'\nimport {\n  type ComponentPublicInstance,\n  computed,\n  getCurrentInstance,\n  type MaybeRefOrGetter,\n  nextTick,\n  onMounted,\n  readonly,\n  type Ref,\n  ref,\n  toRef,\n  watch,\n} from 'vue'\nimport {getElement} from '../../utils/getElement'\n\ntype ScrollspyList = {\n  id: string | null\n  el: HTMLElement | null\n  visible: boolean\n  text: string | null\n}[]\n\ninterface ScrollspyReturn {\n  current: Readonly<Ref<string | null>>\n  list: Readonly<Ref<ScrollspyList>>\n  content: Ref<HTMLElement | undefined>\n  target: Ref<HTMLElement | undefined>\n  scrollIntoView: (event: MouseEvent) => void\n  updateList: () => void\n  cleanup: () => void\n}\n\ninterface ScrollspyOptions {\n  contentQuery: string\n  targetQuery: string\n  manual: boolean\n  root: string | ComponentPublicInstance | HTMLElement | null\n  rootMargin: string\n  threshold: number | number[]\n  watchChanges: boolean\n}\n\nexport const useScrollspy = (\n  content: MaybeRefOrGetter<string | ComponentPublicInstance | HTMLElement | null>,\n  target: MaybeRefOrGetter<string | ComponentPublicInstance | HTMLElement | null>,\n  options: Readonly<Partial<ScrollspyOptions>> = {}\n): ScrollspyReturn => {\n  const cont = toRef(content)\n  const tar = toRef(target)\n\n  const resolvedContent = ref(getElement(cont.value))\n  const resolvedTarget = ref(getElement(tar.value))\n\n  watch([cont, tar], () => {\n    updateList()\n  })\n  const {\n    contentQuery = ':scope > [id]',\n    targetQuery = '[href]',\n    manual = false,\n    root,\n    rootMargin = '0px 0px -25%',\n    threshold = [0.1, 0.5, 1],\n    watchChanges = true,\n  } = options\n  const current = ref<string | null>(null)\n  const list = ref<ScrollspyList>([])\n  const nodeList = ref<HTMLElement[]>([])\n\n  // are we called in directive?\n  const ctx = getCurrentInstance()\n  if (!ctx) {\n    nextTick(() => {\n      updateList()\n    })\n  } else {\n    onMounted(() => {\n      syncRef(cont, resolvedContent, {\n        transform: {\n          ltr: (v) => getElement(v),\n        },\n        direction: 'ltr',\n        immediate: true,\n      })\n      syncRef(tar, resolvedTarget, {\n        transform: {\n          ltr: (v) => getElement(v),\n        },\n        direction: 'ltr',\n        immediate: true,\n      })\n      updateList()\n    })\n  }\n\n  const updateList = () => {\n    nodeList.value = resolvedContent.value\n      ? (Array.from(resolvedContent.value.querySelectorAll(contentQuery)) as HTMLElement[])\n      : []\n    list.value = nodeList.value.map((el) => ({\n      id: el.id,\n      el,\n      visible: false,\n      text: el.textContent,\n    }))\n  }\n\n  let isScrollingDown = true\n  let previousScrollTop = 0\n  const scrollRoot = computed(() =>\n    resolvedContent.value && getComputedStyle(resolvedContent.value).overflowY === 'visible'\n      ? null\n      : resolvedContent.value\n  )\n\n  const iobs = useIntersectionObserver(\n    nodeList,\n    (entries) => {\n      const scrollTop = (scrollRoot.value || document?.documentElement)?.scrollTop\n      isScrollingDown = scrollTop > previousScrollTop\n      previousScrollTop = scrollTop\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          list.value.forEach((node) => {\n            if (node.el === entry.target) {\n              node.visible = true\n            }\n          })\n          return\n        }\n        list.value.forEach((node) => {\n          if (node.el === entry.target) {\n            node.visible = false\n          }\n        })\n      })\n      let newId: string | null = null\n      if (isScrollingDown) {\n        newId = [...list.value].reverse().find((node) => node.visible)?.id || null\n      } else {\n        newId = list.value.find((node) => node.visible)?.id || null\n      }\n      if (newId !== null) {\n        current.value = newId\n      }\n      if (!current.value) {\n        current.value = list.value[0]?.id || null\n      }\n    },\n    {\n      root: root ? getElement(root) : scrollRoot,\n      rootMargin,\n      threshold,\n    }\n  )\n  watch(current, (newId) => {\n    if (manual) return\n    const nodes = resolvedTarget.value?.querySelectorAll(targetQuery)\n    if (nodes === undefined) return\n    let foundParent = false\n    let activeElement: HTMLElement | null = null\n    nodes.forEach((node) => {\n      const parentDropdown = node.closest('.dropdown')\n\n      if (node.getAttribute('href')?.includes(`#${newId}`)) {\n        activeElement = node as HTMLElement\n        node.classList.add('active')\n        if (parentDropdown) {\n          parentDropdown?.querySelector('.dropdown-toggle')?.classList.add('active')\n          foundParent = true\n        }\n        let parentNav = node.closest('.nav')?.previousSibling as HTMLElement\n        while (parentNav?.classList?.contains('nav-item')) {\n          foundParent = true\n          parentNav.querySelector('.nav-link')?.classList.add('active')\n          parentNav = parentNav.closest('.nav')?.previousSibling as HTMLElement\n        }\n      } else {\n        node.classList.remove('active')\n        if (parentDropdown && !foundParent) {\n          parentDropdown?.querySelector('.dropdown-toggle')?.classList.remove('active')\n        }\n\n        if (!foundParent) {\n          let parentNav = node.closest('.nav')?.previousSibling as HTMLElement\n          while (parentNav?.classList?.contains('nav-item')) {\n            foundParent = true\n            if (parentNav.querySelector('.nav-link') !== activeElement) {\n              parentNav.querySelector('.nav-link')?.classList.remove('active')\n            }\n            parentNav = parentNav.closest('.nav')?.previousSibling as HTMLElement\n          }\n        }\n      }\n    })\n  })\n\n  const mobs = !watchChanges\n    ? {stop: () => {}}\n    : useMutationObserver(\n        resolvedContent,\n        () => {\n          updateList()\n        },\n        {\n          childList: true,\n        }\n      )\n  const scrollIntoView = (event: Readonly<MouseEvent>, smooth: boolean = false) => {\n    event.preventDefault()\n    const href = (event.target as HTMLElement)?.getAttribute?.('href')\n    const el: HTMLElement | null = href ? document?.querySelector(href) : null\n    // console.log('scrollIntoView', event, el, content.value.$el)\n    if (el && resolvedContent.value) {\n      if (resolvedContent.value.scrollTo) {\n        resolvedContent.value.scrollTo({top: el.offsetTop, behavior: smooth ? 'smooth' : 'auto'})\n      } else {\n        resolvedContent.value.scrollTop = el.offsetTop\n      }\n    }\n  }\n  const cleanup = () => {\n    iobs.stop()\n    mobs.stop()\n  }\n  return {\n    current: readonly(current),\n    list,\n    content: resolvedContent,\n    target: resolvedTarget,\n    scrollIntoView,\n    updateList,\n    cleanup,\n  }\n}\n"],"names":["content","target","options","cont","toRef","tar","resolvedContent","ref","getElement","value","resolvedTarget","watch","updateList","contentQuery","targetQuery","manual","root","rootMargin","threshold","watchChanges","current","list","nodeList","getCurrentInstance","onMounted","syncRef","transform","ltr","v","direction","immediate","nextTick","Array","from","querySelectorAll","map","el","id","visible","text","textContent","isScrollingDown","previousScrollTop","scrollRoot","computed","getComputedStyle","overflowY","iobs","useIntersectionObserver","entries","scrollTop","document","documentElement","forEach","entry","isIntersecting","node","newId","reverse","find","nodes","foundParent","activeElement","parentDropdown","closest","getAttribute","includes","classList","add","querySelector","parentNav","previousSibling","contains","remove","mobs","useMutationObserver","childList","stop","readonly","scrollIntoView","event","smooth","preventDefault","href","scrollTo","top","offsetTop","behavior","cleanup"],"mappings":"yPA2C4B,CAC1BA,EACAC,EACAC,EAA+C,CAAA,KAE/C,MAAMC,EAAOC,EAAAA,MAAMJ,GACbK,EAAMD,EAAAA,MAAMH,GAEZK,EAAkBC,EAAAA,IAAIC,EAAAA,WAAWL,EAAKM,QACtCC,EAAiBH,EAAAA,IAAIC,EAAAA,WAAWH,EAAII,QAE1CE,EAAAA,MAAM,CAACR,EAAME,GAAM,KACjBO,MAEF,MAAMC,aACJA,EAAe,gBAAAC,YACfA,EAAc,SAAAC,OACdA,GAAS,EAAAC,KACTA,EAAAC,WACAA,EAAa,eAAAC,UACbA,EAAY,CAAC,GAAK,GAAK,GAACC,aACxBA,GAAe,GACbjB,EACEkB,EAAUb,EAAAA,IAAmB,MAC7Bc,EAAOd,EAAAA,IAAmB,IAC1Be,EAAWf,EAAAA,IAAmB,IAGxBgB,EAAAA,qBAMVC,EAAAA,UAAU,KACRC,EAAAA,QAAQtB,EAAMG,EAAiB,CAC7BoB,UAAW,CACTC,IAAMC,GAAMpB,EAAAA,WAAWoB,IAEzBC,UAAW,MACXC,WAAW,IAEbL,EAAAA,QAAQpB,EAAKK,EAAgB,CAC3BgB,UAAW,CACTC,IAAMC,GAAMpB,EAAAA,WAAWoB,IAEzBC,UAAW,MACXC,WAAW,IAEblB,MAnBFmB,EAAAA,SAAS,KACPnB,MAsBJ,MAAMA,EAAa,KACjBU,EAASb,MAAQH,EAAgBG,MAC5BuB,MAAMC,KAAK3B,EAAgBG,MAAMyB,iBAAiBrB,IACnD,GACJQ,EAAKZ,MAAQa,EAASb,MAAM0B,IAAKC,IAAA,CAC/BC,GAAID,EAAGC,GACPD,KACAE,SAAS,EACTC,KAAMH,EAAGI,gBAIb,IAAIC,GAAkB,EAClBC,EAAoB,EACxB,MAAMC,EAAaC,EAAAA,SAAS,IAC1BtC,EAAgBG,OAA+D,YAAtDoC,iBAAiBvC,EAAgBG,OAAOqC,UAC7D,KACAxC,EAAgBG,OAGhBsC,EAAOC,EAAAA,wBACX1B,EACC2B,IACC,MAAMC,GAAaP,EAAWlC,OAAS0C,UAAUC,kBAAkBF,UACnET,EAAkBS,EAAYR,EAC9BA,EAAoBQ,EACpBD,EAAQI,QAASC,IACXA,EAAMC,eACRlC,EAAKZ,MAAM4C,QAASG,IACdA,EAAKpB,KAAOkB,EAAMrD,SACpBuD,EAAKlB,SAAU,KAKrBjB,EAAKZ,MAAM4C,QAASG,IACdA,EAAKpB,KAAOkB,EAAMrD,SACpBuD,EAAKlB,SAAU,OAIrB,IAAImB,EAAuB,KAEzBA,EADEhB,EACM,IAAIpB,EAAKZ,OAAOiD,UAAUC,KAAMH,GAASA,EAAKlB,UAAUD,IAAM,KAE9DhB,EAAKZ,MAAMkD,KAAMH,GAASA,EAAKlB,UAAUD,IAAM,KAE3C,OAAVoB,IACFrC,EAAQX,MAAQgD,GAEbrC,EAAQX,QACXW,EAAQX,MAAQY,EAAKZ,MAAM,IAAI4B,IAAM,OAGzC,CACErB,KAAMA,EAAOR,aAAWQ,GAAQ2B,EAChC1B,aACAC,cAGJP,QAAMS,EAAUqC,IACd,GAAI1C,EAAQ,OACZ,MAAM6C,EAAQlD,EAAeD,OAAOyB,iBAAiBpB,GACrD,QAAc,IAAV8C,EAAqB,OACzB,IAAIC,GAAc,EACdC,EAAoC,KACxCF,EAAMP,QAASG,IACb,MAAMO,EAAiBP,EAAKQ,QAAQ,aAEpC,GAAIR,EAAKS,aAAa,SAASC,SAAS,IAAIT,KAAU,CACpDK,EAAgBN,EAChBA,EAAKW,UAAUC,IAAI,UACfL,IACFA,GAAgBM,cAAc,qBAAqBF,UAAUC,IAAI,UACjEP,GAAc,GAEhB,IAAIS,EAAYd,EAAKQ,QAAQ,SAASO,gBACtC,KAAOD,GAAWH,WAAWK,SAAS,aACpCX,GAAc,EACdS,EAAUD,cAAc,cAAcF,UAAUC,IAAI,UACpDE,EAAYA,EAAUN,QAAQ,SAASO,eAE3C,MAME,GALAf,EAAKW,UAAUM,OAAO,UAClBV,IAAmBF,GACrBE,GAAgBM,cAAc,qBAAqBF,UAAUM,OAAO,WAGjEZ,EAAa,CAChB,IAAIS,EAAYd,EAAKQ,QAAQ,SAASO,gBACtC,KAAOD,GAAWH,WAAWK,SAAS,aACpCX,GAAc,EACVS,EAAUD,cAAc,eAAiBP,GAC3CQ,EAAUD,cAAc,cAAcF,UAAUM,OAAO,UAEzDH,EAAYA,EAAUN,QAAQ,SAASO,eAE3C,MAKN,MAAMG,EAAQvD,EAEVwD,EAAAA,oBACErE,EACA,KACEM,KAEF,CACEgE,WAAW,IAPf,CAACC,KAAM,QA2BX,MAAO,CACLzD,QAAS0D,EAAAA,SAAS1D,GAClBC,OACArB,QAASM,EACTL,OAAQS,EACRqE,eAtBqB,CAACC,EAA6BC,GAAkB,KACrED,EAAME,iBACN,MAAMC,EAAQH,EAAM/E,QAAwBgE,eAAe,QACrD7B,EAAyB+C,EAAOhC,UAAUkB,cAAcc,GAAQ,KAElE/C,GAAM9B,EAAgBG,QACpBH,EAAgBG,MAAM2E,SACxB9E,EAAgBG,MAAM2E,SAAS,CAACC,IAAKjD,EAAGkD,UAAWC,SAAUN,EAAS,SAAW,SAEjF3E,EAAgBG,MAAMyC,UAAYd,EAAGkD,YAczC1E,aACA4E,QAXc,KACdzC,EAAK8B,OACLH,EAAKG"}