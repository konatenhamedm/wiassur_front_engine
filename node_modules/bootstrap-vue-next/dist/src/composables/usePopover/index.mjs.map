{"version":3,"file":"index.mjs","sources":["../../../../src/composables/usePopover/index.ts"],"sourcesContent":["import {\n  inject,\n  isReadonly,\n  isRef,\n  markRaw,\n  onScopeDispose,\n  type Ref,\n  toRef,\n  toValue,\n  watch,\n} from 'vue'\nimport {orchestratorRegistryKey} from '../../utils/keys'\nimport type {\n  OrchestratorCreateOptions,\n  PopoverOrchestratorArrayValue,\n  PopoverOrchestratorCreateParam,\n  PopoverOrchestratorParam,\n  PromiseWithComponent,\n  TooltipOrchestratorArrayValue,\n  TooltipOrchestratorCreateParam,\n  TooltipOrchestratorParam,\n} from '../../types/ComponentOrchestratorTypes'\nimport {BPopover, BTooltip} from '../../components'\nimport {buildPromise} from '../orchestratorShared'\n\nexport const usePopover = () => {\n  const orchestratorRegistry = inject(orchestratorRegistryKey)\n  if (!orchestratorRegistry) {\n    throw new Error(\n      'usePopover() must be called within setup(), and BApp, useRegistry or plugin must be installed/provided.'\n    )\n  }\n\n  const {store, _isOrchestratorInstalled} = orchestratorRegistry\n\n  /**\n   * Create a popover or tooltip\n   * @param obj The popover or tooltip props\n   * @param tooltip If true, create a tooltip, otherwise create a popover\n   * @returns {PromiseWithComponent<typeof BPopover | typeof BTooltip, PopoverOrchestratorParam>} A promise object with methods to control the popover (show, hide, toggle, get, set, destroy)\n   */\n  const create = (\n    obj: PopoverOrchestratorCreateParam | TooltipOrchestratorCreateParam,\n    tooltip?: boolean,\n    options: OrchestratorCreateOptions = {keep: true}\n  ): PromiseWithComponent<\n    typeof BPopover | typeof BTooltip,\n    PopoverOrchestratorParam | TooltipOrchestratorParam\n  > => {\n    if (!_isOrchestratorInstalled.value) {\n      throw new Error(\n        'The BPopoverOrchestrator component must be mounted to use the popover controller'\n      )\n    }\n\n    const resolvedProps = toRef(obj)\n    const _self = resolvedProps.value?.id || Symbol('Popover controller')\n\n    const promise = buildPromise<\n      typeof BPopover | typeof BTooltip,\n      PopoverOrchestratorParam | TooltipOrchestratorParam,\n      PopoverOrchestratorArrayValue | TooltipOrchestratorArrayValue\n    >(_self, store as Ref<PopoverOrchestratorArrayValue[] | TooltipOrchestratorArrayValue[]>)\n\n    promise.stop = watch(\n      resolvedProps,\n      (_newValue) => {\n        const newValue = {...toValue(_newValue)}\n        const previousIndex = store.value.findIndex((el) => el._self === _self)\n        const previous =\n          previousIndex === -1\n            ? {_component: tooltip ? markRaw(BTooltip) : markRaw(BPopover)}\n            : store.value[previousIndex]\n        // if (!previous) return\n        const v: PopoverOrchestratorArrayValue | TooltipOrchestratorArrayValue = tooltip\n          ? ({\n              ...previous,\n              type: 'tooltip',\n              _self,\n              position: 'popover',\n              promise,\n              options,\n            } as TooltipOrchestratorArrayValue)\n          : ({\n              ...previous,\n              type: 'popover',\n              _self,\n              position: 'popover',\n              promise,\n              options,\n            } as PopoverOrchestratorArrayValue)\n\n        for (const key in newValue) {\n          if (key.startsWith('on')) {\n            v[key as keyof PopoverOrchestratorCreateParam] =\n              newValue[key as keyof PopoverOrchestratorCreateParam]\n          } else if (key === 'component' && newValue.component) {\n            v._component = markRaw(newValue.component)\n          } else if (key === 'slots' && newValue.slots) {\n            v.slots = markRaw(newValue.slots)\n          } else {\n            v[key as keyof PopoverOrchestratorCreateParam] = toValue(\n              newValue[key as keyof PopoverOrchestratorCreateParam]\n            )\n          }\n        }\n\n        v.modelValue = v.modelValue ?? false\n        v['onUpdate:modelValue'] = (val: boolean) => {\n          newValue['onUpdate:modelValue']?.(val)\n          const {modelValue} = toValue(obj)\n          if (isRef(obj) && !isRef(modelValue)) obj.value.modelValue = val\n          if (isRef(modelValue) && !isReadonly(modelValue)) {\n            ;(modelValue as Ref<PopoverOrchestratorParam['modelValue']>).value = val\n          }\n          if (v.modelValue !== val) {\n            const popover = store.value.find((el) => el._self === _self)\n            if (popover) {\n              popover.modelValue = val\n            }\n          }\n        }\n        if (previousIndex === -1) {\n          store.value.push(v)\n        } else {\n          store.value.splice(previousIndex, 1, v)\n        }\n      },\n      {\n        immediate: true,\n        deep: true,\n      }\n    )\n\n    onScopeDispose(() => {\n      const popover = store.value.find((el) => el._self === _self)\n      if (popover) {\n        popover.promise.value.destroy?.()\n      }\n    }, true)\n\n    return promise.value\n  }\n\n  const tooltip = (\n    obj: TooltipOrchestratorCreateParam,\n    options: OrchestratorCreateOptions = {keep: true}\n  ) => create(obj, true, options)\n\n  const popover = (\n    obj: PopoverOrchestratorCreateParam,\n    options: OrchestratorCreateOptions = {keep: true}\n  ) => create(obj, false, options)\n\n  return {\n    _isOrchestratorInstalled,\n    create,\n    popover,\n    tooltip,\n    store,\n  }\n}\n\n/**\n * @deprecated use usePopover() instead.\n * @returns {ReturnType<typeof usePopover>} The popover controller\n */\nexport const usePopoverController = usePopover\n"],"names":["tooltip","BTooltip","BPopover","popover"],"mappings":"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"}