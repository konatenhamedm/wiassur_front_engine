import { inject, toRef, watch, toValue, markRaw, onScopeDispose, isRef, isReadonly } from "vue";
import { o as orchestratorRegistryKey } from "../../../keys-BLeKMItg.mjs";
import "../../../BootstrapVueOptions-DSytNWdb.mjs";
import "../../../ConditionalTeleport.vue_vue_type_script_lang-Cp-egLmm.mjs";
import { b as buildPromise } from "../../../orchestratorShared-BTzXOM4N.mjs";
import "../../../ConditionalWrapper.vue_vue_type_script_lang-IX_NpHH-.mjs";
import { _ as _sfc_main$1 } from "../../../floatingUi-CE0Z1avc.mjs";
import "../../../useTransitions-BAT154ve.mjs";
import "../../../tableUtils-Jp7dzXjS.mjs";
import { _ as _sfc_main } from "../../../BTooltip.vue_vue_type_script_setup_true_lang-BIyqHvau.mjs";
const usePopover = () => {
  const orchestratorRegistry = inject(orchestratorRegistryKey);
  if (!orchestratorRegistry) {
    throw new Error(
      "usePopover() must be called within setup(), and BApp, useRegistry or plugin must be installed/provided."
    );
  }
  const { store, _isOrchestratorInstalled } = orchestratorRegistry;
  const create = (obj, tooltip2, options = { keep: true }) => {
    if (!_isOrchestratorInstalled.value) {
      throw new Error(
        "The BPopoverOrchestrator component must be mounted to use the popover controller"
      );
    }
    const resolvedProps = toRef(obj);
    const _self = resolvedProps.value?.id || Symbol("Popover controller");
    const promise = buildPromise(_self, store);
    promise.stop = watch(
      resolvedProps,
      (_newValue) => {
        const newValue = { ...toValue(_newValue) };
        const previousIndex = store.value.findIndex((el) => el._self === _self);
        const previous = previousIndex === -1 ? { _component: tooltip2 ? markRaw(_sfc_main) : markRaw(_sfc_main$1) } : store.value[previousIndex];
        const v = tooltip2 ? {
          ...previous,
          type: "tooltip",
          _self,
          position: "popover",
          promise,
          options
        } : {
          ...previous,
          type: "popover",
          _self,
          position: "popover",
          promise,
          options
        };
        for (const key in newValue) {
          if (key.startsWith("on")) {
            v[key] = newValue[key];
          } else if (key === "component" && newValue.component) {
            v._component = markRaw(newValue.component);
          } else if (key === "slots" && newValue.slots) {
            v.slots = markRaw(newValue.slots);
          } else {
            v[key] = toValue(
              newValue[key]
            );
          }
        }
        v.modelValue = v.modelValue ?? false;
        v["onUpdate:modelValue"] = (val) => {
          newValue["onUpdate:modelValue"]?.(val);
          const { modelValue } = toValue(obj);
          if (isRef(obj) && !isRef(modelValue)) obj.value.modelValue = val;
          if (isRef(modelValue) && !isReadonly(modelValue)) {
            modelValue.value = val;
          }
          if (v.modelValue !== val) {
            const popover2 = store.value.find((el) => el._self === _self);
            if (popover2) {
              popover2.modelValue = val;
            }
          }
        };
        if (previousIndex === -1) {
          store.value.push(v);
        } else {
          store.value.splice(previousIndex, 1, v);
        }
      },
      {
        immediate: true,
        deep: true
      }
    );
    onScopeDispose(() => {
      const popover2 = store.value.find((el) => el._self === _self);
      if (popover2) {
        popover2.promise.value.destroy?.();
      }
    }, true);
    return promise.value;
  };
  const tooltip = (obj, options = { keep: true }) => create(obj, true, options);
  const popover = (obj, options = { keep: true }) => create(obj, false, options);
  return {
    _isOrchestratorInstalled,
    create,
    popover,
    tooltip,
    store
  };
};
const usePopoverController = usePopover;
export {
  usePopover,
  usePopoverController
};
//# sourceMappingURL=index.mjs.map
