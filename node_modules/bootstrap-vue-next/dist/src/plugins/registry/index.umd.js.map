{"version":3,"file":"index.umd.js","sources":["../../../../src/plugins/registry/index.ts"],"sourcesContent":["import {\n  breadcrumbGlobalIndexKey,\n  breadcrumbRegistryKey,\n  modalManagerKey,\n  showHideRegistryKey,\n} from '../../utils/keys'\nimport {_newShowHideRegistry} from '../../composables/useRegistry'\nimport type {BreadcrumbItemRaw} from '../../types/BreadcrumbTypes'\nimport {type ComponentInternalInstance, computed, type Plugin, type Ref, ref} from 'vue'\n\nexport const registryPlugin: Plugin = {\n  install(app) {\n    // Provide global showHide registry\n    const {register, values} = _newShowHideRegistry()\n    app.provide(showHideRegistryKey, {register, values})\n\n    // Provide global breadcrumb registry\n    const items = ref<Record<string, BreadcrumbItemRaw[]>>({\n      [breadcrumbGlobalIndexKey]: [],\n    })\n    const reset = (key: string = breadcrumbGlobalIndexKey) => {\n      items.value[key] = []\n    }\n    app.provide(breadcrumbRegistryKey, {items, reset})\n\n    /**\n     * A collection of all currently active modals\n     *\n     * It was made into a map so that if a modal is ever added into the stack twice, it will not be duplicated\n     * (if modelValue is true when started, it gets added in setup scope, then a watcher is triggered and it gets added again in the next tick)\n     * Didn't feel like fixing it in the modal component, so I just made it a map\n     */\n    const stack: Ref<Map<number, ComponentInternalInstance>> = ref(new Map())\n\n    const countStack = computed(() => stack.value.size)\n    const valuesStack = computed(() => [...stack.value.values()])\n    const lastStack = computed(() => valuesStack.value[valuesStack.value.length - 1])\n\n    const pushStack = (modal: Readonly<ComponentInternalInstance>) => {\n      stack.value.set(modal.uid, modal)\n    }\n    const removeStack = (modal: Readonly<ComponentInternalInstance>) => {\n      stack.value.delete(modal.uid)\n    }\n\n    /**\n     * A collection of all registered modals\n     */\n    const registry: Ref<Map<number, ComponentInternalInstance>> = ref(new Map())\n\n    // Utility getters not made, would not be used (count, last)\n\n    const pushRegistry = (modal: Readonly<ComponentInternalInstance>) => {\n      registry.value.set(modal.uid, modal)\n    }\n    const removeRegistry = (modal: Readonly<ComponentInternalInstance>) => {\n      registry.value.delete(modal.uid)\n    }\n\n    app.provide(modalManagerKey, {\n      countStack,\n      lastStack,\n      registry: computed(() => registry.value),\n      stack: valuesStack,\n      pushStack,\n      removeStack,\n      pushRegistry,\n      removeRegistry,\n    })\n  },\n}\n"],"names":["registryPlugin","install","app","register","values","_newShowHideRegistry","provide","showHideRegistryKey","items","ref","breadcrumbGlobalIndexKey","breadcrumbRegistryKey","reset","key","value","stack","Map","countStack","computed","size","valuesStack","lastStack","length","registry","modalManagerKey","pushStack","modal","set","uid","removeStack","delete","pushRegistry","removeRegistry"],"mappings":"sMAUaA,EAAyB,CACpC,OAAAC,CAAQC,GAEN,MAAMC,SAACA,EAAAC,OAAUA,GAAUC,yBAC3BH,EAAII,QAAQC,EAAAA,oBAAqB,CAACJ,WAAUC,WAG5C,MAAMI,EAAQC,EAAAA,IAAyC,CACrD,CAACC,4BAA2B,KAK9BR,EAAII,QAAQK,EAAAA,sBAAuB,CAACH,QAAOI,MAH7B,CAACC,EAAcH,8BAC3BF,EAAMM,MAAMD,GAAO,MAWrB,MAAME,EAAqDN,EAAAA,IAAI,IAAIO,KAE7DC,EAAaC,EAAAA,SAAS,IAAMH,EAAMD,MAAMK,MACxCC,EAAcF,EAAAA,SAAS,IAAM,IAAIH,EAAMD,MAAMV,WAC7CiB,EAAYH,WAAS,IAAME,EAAYN,MAAMM,EAAYN,MAAMQ,OAAS,IAYxEC,EAAwDd,EAAAA,IAAI,IAAIO,KAWtEd,EAAII,QAAQkB,kBAAiB,CAC3BP,aACAI,YACAE,SAAUL,EAAAA,SAAS,IAAMK,EAAST,OAClCC,MAAOK,EACPK,UA1BiBC,IACjBX,EAAMD,MAAMa,IAAID,EAAME,IAAKF,IA0B3BG,YAxBmBH,IACnBX,EAAMD,MAAMgB,OAAOJ,EAAME,MAwBzBG,aAdoBL,IACpBH,EAAST,MAAMa,IAAID,EAAME,IAAKF,IAc9BM,eAZsBN,IACtBH,EAAST,MAAMgB,OAAOJ,EAAME,OAahC"}