{"version":3,"file":"index.mjs","sources":["../../../../src/plugins/registry/index.ts"],"sourcesContent":["import {\n  breadcrumbGlobalIndexKey,\n  breadcrumbRegistryKey,\n  modalManagerKey,\n  showHideRegistryKey,\n} from '../../utils/keys'\nimport {_newShowHideRegistry} from '../../composables/useRegistry'\nimport type {BreadcrumbItemRaw} from '../../types/BreadcrumbTypes'\nimport {type ComponentInternalInstance, computed, type Plugin, type Ref, ref} from 'vue'\n\nexport const registryPlugin: Plugin = {\n  install(app) {\n    // Provide global showHide registry\n    const {register, values} = _newShowHideRegistry()\n    app.provide(showHideRegistryKey, {register, values})\n\n    // Provide global breadcrumb registry\n    const items = ref<Record<string, BreadcrumbItemRaw[]>>({\n      [breadcrumbGlobalIndexKey]: [],\n    })\n    const reset = (key: string = breadcrumbGlobalIndexKey) => {\n      items.value[key] = []\n    }\n    app.provide(breadcrumbRegistryKey, {items, reset})\n\n    /**\n     * A collection of all currently active modals\n     *\n     * It was made into a map so that if a modal is ever added into the stack twice, it will not be duplicated\n     * (if modelValue is true when started, it gets added in setup scope, then a watcher is triggered and it gets added again in the next tick)\n     * Didn't feel like fixing it in the modal component, so I just made it a map\n     */\n    const stack: Ref<Map<number, ComponentInternalInstance>> = ref(new Map())\n\n    const countStack = computed(() => stack.value.size)\n    const valuesStack = computed(() => [...stack.value.values()])\n    const lastStack = computed(() => valuesStack.value[valuesStack.value.length - 1])\n\n    const pushStack = (modal: Readonly<ComponentInternalInstance>) => {\n      stack.value.set(modal.uid, modal)\n    }\n    const removeStack = (modal: Readonly<ComponentInternalInstance>) => {\n      stack.value.delete(modal.uid)\n    }\n\n    /**\n     * A collection of all registered modals\n     */\n    const registry: Ref<Map<number, ComponentInternalInstance>> = ref(new Map())\n\n    // Utility getters not made, would not be used (count, last)\n\n    const pushRegistry = (modal: Readonly<ComponentInternalInstance>) => {\n      registry.value.set(modal.uid, modal)\n    }\n    const removeRegistry = (modal: Readonly<ComponentInternalInstance>) => {\n      registry.value.delete(modal.uid)\n    }\n\n    app.provide(modalManagerKey, {\n      countStack,\n      lastStack,\n      registry: computed(() => registry.value),\n      stack: valuesStack,\n      pushStack,\n      removeStack,\n      pushRegistry,\n      removeRegistry,\n    })\n  },\n}\n"],"names":[],"mappings":";;;AAUO,MAAM,iBAAyB;AAAA,EACpC,QAAQ,KAAK;AAEX,UAAM,EAAC,UAAU,OAAA,IAAU,qBAAA;AAC3B,QAAI,QAAQ,qBAAqB,EAAC,UAAU,QAAO;AAGnD,UAAM,QAAQ,IAAyC;AAAA,MACrD,CAAC,wBAAwB,GAAG,CAAA;AAAA,IAAC,CAC9B;AACD,UAAM,QAAQ,CAAC,MAAc,6BAA6B;AACxD,YAAM,MAAM,GAAG,IAAI,CAAA;AAAA,IACrB;AACA,QAAI,QAAQ,uBAAuB,EAAC,OAAO,OAAM;AASjD,UAAM,QAAqD,IAAI,oBAAI,KAAK;AAExE,UAAM,aAAa,SAAS,MAAM,MAAM,MAAM,IAAI;AAClD,UAAM,cAAc,SAAS,MAAM,CAAC,GAAG,MAAM,MAAM,OAAA,CAAQ,CAAC;AAC5D,UAAM,YAAY,SAAS,MAAM,YAAY,MAAM,YAAY,MAAM,SAAS,CAAC,CAAC;AAEhF,UAAM,YAAY,CAAC,UAA+C;AAChE,YAAM,MAAM,IAAI,MAAM,KAAK,KAAK;AAAA,IAClC;AACA,UAAM,cAAc,CAAC,UAA+C;AAClE,YAAM,MAAM,OAAO,MAAM,GAAG;AAAA,IAC9B;AAKA,UAAM,WAAwD,IAAI,oBAAI,KAAK;AAI3E,UAAM,eAAe,CAAC,UAA+C;AACnE,eAAS,MAAM,IAAI,MAAM,KAAK,KAAK;AAAA,IACrC;AACA,UAAM,iBAAiB,CAAC,UAA+C;AACrE,eAAS,MAAM,OAAO,MAAM,GAAG;AAAA,IACjC;AAEA,QAAI,QAAQ,iBAAiB;AAAA,MAC3B;AAAA,MACA;AAAA,MACA,UAAU,SAAS,MAAM,SAAS,KAAK;AAAA,MACvC,OAAO;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAAA,EACH;AACF;"}