{"version":3,"file":"index.mjs","sources":["../../../../src/directives/BToggle/index.ts"],"sourcesContent":["import {RX_HASH, RX_HASH_ID, RX_SPACE_SPLIT} from '../../utils/constants'\nimport {type Directive, type DirectiveBinding, toValue, type VNode} from 'vue'\nimport {findProvides} from '../utils'\nimport {type RegisterShowHideValue, showHideRegistryKey} from '../../utils/keys'\n\nconst getTargets = (\n  binding: DirectiveBinding<string | readonly string[] | undefined>,\n  el: Readonly<Element>\n) => {\n  const {modifiers, arg, value} = binding\n  // Any modifiers are considered target Ids\n  const targets = Object.keys(modifiers || {})\n\n  // If value is a string, split out individual targets (if space delimited)\n  const localValue = typeof value === 'string' ? value.split(RX_SPACE_SPLIT) : value\n\n  // Support target Id as link href (`href=\"#id\"`)\n  if (el.tagName.toLowerCase() === 'a') {\n    const href = el.getAttribute('href') || ''\n    if (RX_HASH_ID.test(href)) {\n      targets.push(href.replace(RX_HASH, ''))\n    }\n  }\n\n  // Add Id from `arg` (if provided), and support value\n  // as a single string Id or an array of string Ids\n  // If `value` is not an array or string, then it gets filtered out\n  Array.prototype.concat\n    .apply([], [arg, localValue])\n    .forEach((t) => typeof t === 'string' && targets.push(t))\n\n  // Return only unique and truthy target Ids\n  return targets.filter((t, index, arr) => t && arr.indexOf(t) === index)\n}\n\nconst handleUpdate = (\n  el: Element,\n  binding: DirectiveBinding<string | readonly string[] | undefined>,\n  vnode: VNode\n) => {\n  // Determine targets\n  const targets = getTargets(binding, el)\n  if (targets.length === 0) return\n\n  const provides = findProvides(binding, vnode)\n  const showHideMap = (provides as Record<symbol, RegisterShowHideValue>)[showHideRegistryKey]\n    ?.values\n  if ((el as HTMLElement).dataset.bvtoggle) {\n    const oldTargets = ((el as HTMLElement).dataset.bvtoggle || '').split(' ')\n    if (oldTargets.length === 0) return\n    for (const targetId of oldTargets) {\n      const showHide = showHideMap?.value.get(targetId)\n      if (!showHide) {\n        continue\n      }\n      if (!targets.includes(targetId)) {\n        toValue(showHide).unregisterTrigger('click', el, false)\n      }\n    }\n  }\n  ;(el as HTMLElement).dataset.bvtoggle = targets.join(' ')\n\n  targets.forEach(async (targetId) => {\n    let count = 0\n    // Keep looking until showHide is found, giving up after 400ms or directive is unmounted\n    while (count < 5 && (el as HTMLElement).dataset.bvtoggle) {\n      const showHide = showHideMap?.value.get(targetId)\n      if (!showHide) {\n        count++\n        await new Promise((resolve) => setTimeout(resolve, 100))\n        if (count < 4) continue\n        // eslint-disable-next-line no-console\n        console.warn(`[v-b-toggle] Target with ID ${targetId} not found`)\n        break\n      }\n      // Register the trigger element\n\n      toValue(showHide).unregisterTrigger('click', el, false)\n      toValue(showHide).registerTrigger('click', el)\n      break\n    }\n  })\n\n  el.setAttribute('aria-controls', targets.join(' '))\n}\nconst handleUnmount = (\n  el: Element,\n  binding: DirectiveBinding<string | readonly string[] | undefined>,\n  vnode: VNode\n) => {\n  // Determine targets\n  const targets = getTargets(binding, el)\n  if (targets.length === 0) return\n  const provides = findProvides(binding, vnode)\n  const showHideMap = (provides as Record<symbol, RegisterShowHideValue>)[showHideRegistryKey]\n    ?.values\n\n  targets.forEach((targetId) => {\n    const showHide = showHideMap?.value.get(targetId)\n    if (!showHide) {\n      return\n    }\n    toValue(showHide).unregisterTrigger('click', el, false)\n  })\n\n  el.removeAttribute('aria-controls')\n  el.removeAttribute('aria-expanded')\n  el.classList.remove('collapsed')\n  el.classList.remove('not-collapsed')\n  delete (el as HTMLElement).dataset.bvtoggle\n}\n\nexport const vBToggle: Directive<Element> = {\n  mounted: handleUpdate,\n  updated: handleUpdate,\n  unmounted: handleUnmount,\n}\n"],"names":[],"mappings":";;;;AAKA,MAAM,aAAa,CACjB,SACA,OACG;AACH,QAAM,EAAC,WAAW,KAAK,MAAA,IAAS;AAEhC,QAAM,UAAU,OAAO,KAAK,aAAa,CAAA,CAAE;AAG3C,QAAM,aAAa,OAAO,UAAU,WAAW,MAAM,MAAM,cAAc,IAAI;AAG7E,MAAI,GAAG,QAAQ,YAAA,MAAkB,KAAK;AACpC,UAAM,OAAO,GAAG,aAAa,MAAM,KAAK;AACxC,QAAI,WAAW,KAAK,IAAI,GAAG;AACzB,cAAQ,KAAK,KAAK,QAAQ,SAAS,EAAE,CAAC;AAAA,IACxC;AAAA,EACF;AAKA,QAAM,UAAU,OACb,MAAM,CAAA,GAAI,CAAC,KAAK,UAAU,CAAC,EAC3B,QAAQ,CAAC,MAAM,OAAO,MAAM,YAAY,QAAQ,KAAK,CAAC,CAAC;AAG1D,SAAO,QAAQ,OAAO,CAAC,GAAG,OAAO,QAAQ,KAAK,IAAI,QAAQ,CAAC,MAAM,KAAK;AACxE;AAEA,MAAM,eAAe,CACnB,IACA,SACA,UACG;AAEH,QAAM,UAAU,WAAW,SAAS,EAAE;AACtC,MAAI,QAAQ,WAAW,EAAG;AAE1B,QAAM,WAAW,aAAa,SAAS,KAAK;AAC5C,QAAM,cAAe,SAAmD,mBAAmB,GACvF;AACJ,MAAK,GAAmB,QAAQ,UAAU;AACxC,UAAM,cAAe,GAAmB,QAAQ,YAAY,IAAI,MAAM,GAAG;AACzE,QAAI,WAAW,WAAW,EAAG;AAC7B,eAAW,YAAY,YAAY;AACjC,YAAM,WAAW,aAAa,MAAM,IAAI,QAAQ;AAChD,UAAI,CAAC,UAAU;AACb;AAAA,MACF;AACA,UAAI,CAAC,QAAQ,SAAS,QAAQ,GAAG;AAC/B,gBAAQ,QAAQ,EAAE,kBAAkB,SAAS,IAAI,KAAK;AAAA,MACxD;AAAA,IACF;AAAA,EACF;AACE,KAAmB,QAAQ,WAAW,QAAQ,KAAK,GAAG;AAExD,UAAQ,QAAQ,OAAO,aAAa;AAClC,QAAI,QAAQ;AAEZ,WAAO,QAAQ,KAAM,GAAmB,QAAQ,UAAU;AACxD,YAAM,WAAW,aAAa,MAAM,IAAI,QAAQ;AAChD,UAAI,CAAC,UAAU;AACb;AACA,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,GAAG,CAAC;AACvD,YAAI,QAAQ,EAAG;AAEf,gBAAQ,KAAK,+BAA+B,QAAQ,YAAY;AAChE;AAAA,MACF;AAGA,cAAQ,QAAQ,EAAE,kBAAkB,SAAS,IAAI,KAAK;AACtD,cAAQ,QAAQ,EAAE,gBAAgB,SAAS,EAAE;AAC7C;AAAA,IACF;AAAA,EACF,CAAC;AAED,KAAG,aAAa,iBAAiB,QAAQ,KAAK,GAAG,CAAC;AACpD;AACA,MAAM,gBAAgB,CACpB,IACA,SACA,UACG;AAEH,QAAM,UAAU,WAAW,SAAS,EAAE;AACtC,MAAI,QAAQ,WAAW,EAAG;AAC1B,QAAM,WAAW,aAAa,SAAS,KAAK;AAC5C,QAAM,cAAe,SAAmD,mBAAmB,GACvF;AAEJ,UAAQ,QAAQ,CAAC,aAAa;AAC5B,UAAM,WAAW,aAAa,MAAM,IAAI,QAAQ;AAChD,QAAI,CAAC,UAAU;AACb;AAAA,IACF;AACA,YAAQ,QAAQ,EAAE,kBAAkB,SAAS,IAAI,KAAK;AAAA,EACxD,CAAC;AAED,KAAG,gBAAgB,eAAe;AAClC,KAAG,gBAAgB,eAAe;AAClC,KAAG,UAAU,OAAO,WAAW;AAC/B,KAAG,UAAU,OAAO,eAAe;AACnC,SAAQ,GAAmB,QAAQ;AACrC;AAEO,MAAM,WAA+B;AAAA,EAC1C,SAAS;AAAA,EACT,SAAS;AAAA,EACT,WAAW;AACb;"}