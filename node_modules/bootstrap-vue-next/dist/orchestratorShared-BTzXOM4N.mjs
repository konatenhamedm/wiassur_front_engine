import { inject, ref, provide, nextTick, toValue } from "vue";
import { o as orchestratorRegistryKey } from "./keys-BLeKMItg.mjs";
function buildPromise(_id, store) {
  let resolveFunc = () => {
  };
  const promise = new Promise((resolve) => {
    resolveFunc = resolve;
  });
  Object.assign(promise, {
    id: _id,
    ref: null,
    show() {
      const refWithMethods = this.ref;
      if (refWithMethods?.show) {
        refWithMethods.show();
      } else return this.set({ modelValue: true });
      return promise;
    },
    hide(trigger) {
      const refWithMethods = this.ref;
      if (refWithMethods?.hide) {
        refWithMethods.hide(trigger, true);
      } else return this.set({ modelValue: false });
      return promise;
    },
    toggle() {
      const currentItem = this.get();
      const refWithMethods = this.ref;
      if (refWithMethods?.toggle) {
        refWithMethods.toggle();
      } else return this.set({ modelValue: !currentItem?.modelValue });
      return promise;
    },
    get() {
      return store.value.find((el) => el._self === _id);
    },
    set(val) {
      const itemIndex = store.value.findIndex((el) => el._self === _id);
      const item = store.value[itemIndex];
      if (item) {
        const v = { ...toValue(item), ...toValue(val) };
        if (item.modelValue !== v.modelValue) {
          item["onUpdate:modelValue"]?.(v.modelValue);
        }
        store.value.splice(itemIndex, 1, {
          ...v,
          title: toValue(v.title),
          body: toValue(v.body),
          modelValue: toValue(v.modelValue)
        });
      }
      return promise;
    },
    async destroy() {
      const item = store.value.find((el) => el._self === _id);
      if (!item) return;
      item.promise.stop?.();
      if (item.modelValue) {
        await new Promise((resolve) => {
          const prev = item["onHidden"];
          item["onHidden"] = (e) => {
            prev?.(e);
            resolve(e);
          };
          nextTick(() => {
            this.hide("destroy");
          });
        });
      }
      store.value.splice(
        store.value.findIndex((el) => el._self === _id),
        1
      );
    },
    async [Symbol.asyncDispose]() {
      await this.destroy();
    }
  });
  return {
    value: promise,
    resolve: resolveFunc,
    stop: void 0
  };
}
const _newOrchestratorRegistry = () => ({
  store: ref([]),
  _isOrchestratorInstalled: ref(false),
  _isToastAppend: ref(false)
});
const useOrchestratorRegistry = () => {
  const orchestratorRegistry = inject(orchestratorRegistryKey, void 0);
  if (orchestratorRegistry) {
    return orchestratorRegistry;
  }
  const newOrchestratorRegistry = _newOrchestratorRegistry();
  provide(orchestratorRegistryKey, newOrchestratorRegistry);
  return newOrchestratorRegistry;
};
export {
  _newOrchestratorRegistry as _,
  buildPromise as b,
  useOrchestratorRegistry as u
};
//# sourceMappingURL=orchestratorShared-BTzXOM4N.mjs.map
