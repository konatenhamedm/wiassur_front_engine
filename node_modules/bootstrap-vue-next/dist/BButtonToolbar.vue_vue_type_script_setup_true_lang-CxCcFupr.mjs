import { defineComponent, provide, computed, createBlock, openBlock, resolveDynamicComponent, unref, normalizeClass, withCtx, renderSlot, useTemplateRef, createElementBlock, nextTick } from "vue";
import { u as useDefaults } from "./useDefaults-DESCdb0p.mjs";
import { b as buttonGroupKey } from "./keys-BLeKMItg.mjs";
import { C as CODE_LEFT, a as CODE_UP, b as CODE_RIGHT, c as CODE_DOWN, m as CODE_HOME, n as CODE_END } from "./constants-Cx335y3L.mjs";
import { s as stopEvent } from "./event-a_bi5ysw.mjs";
import { g as getActiveElement } from "./dom-DVb-f0ZG.mjs";
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: "md" },
    tag: { default: "div" },
    vertical: { type: Boolean, default: false }
  },
  setup(__props) {
    provide(buttonGroupKey, true);
    const _props = __props;
    const props = useDefaults(_props, "BButtonGroup");
    const computedClasses = computed(() => ({
      "btn-group": !props.vertical,
      [`btn-group-${props.size}`]: props.size !== "md",
      "btn-group-vertical": props.vertical
    }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(props).tag), {
        class: normalizeClass(computedClasses.value),
        role: "group",
        "aria-label": unref(props).ariaLabel
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "aria-label"]);
    };
  }
});
const _hoisted_1 = ["role", "aria-label"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    keyNav: { type: Boolean, default: false },
    justify: { type: Boolean, default: false },
    role: { default: "toolbar" }
  },
  setup(__props) {
    const _props = __props;
    const props = useDefaults(_props, "BButtonToolbar");
    const toolbarRef = useTemplateRef("toolbarRef");
    const computedClasses = computed(() => ({
      "justify-content-between": props.justify
    }));
    const getFocusableElements = () => {
      if (!toolbarRef.value) return [];
      const selector = 'button:not(:disabled), [href]:not(:disabled), input:not(:disabled), select:not(:disabled), textarea:not(:disabled), [tabindex]:not([tabindex="-1"]):not(:disabled)';
      const elements = Array.from(toolbarRef.value.querySelectorAll(selector));
      return elements.filter((el) => {
        const style = window.getComputedStyle(el);
        return style.display !== "none" && style.visibility !== "hidden";
      });
    };
    const isDisabled = (element) => element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
    const focusFirst = () => {
      nextTick(() => {
        const elements = getFocusableElements();
        const firstEnabled = elements.find((el) => !isDisabled(el));
        firstEnabled?.focus();
      });
    };
    const focusLast = () => {
      nextTick(() => {
        const elements = getFocusableElements();
        const lastEnabled = elements.reverse().find((el) => !isDisabled(el));
        lastEnabled?.focus();
      });
    };
    const focusPrev = () => {
      nextTick(() => {
        const elements = getFocusableElements();
        const activeElement = getActiveElement();
        const currentIndex = elements.indexOf(activeElement);
        if (currentIndex > 0) {
          for (let i = currentIndex - 1; i >= 0; i--) {
            if (!isDisabled(elements[i])) {
              elements[i]?.focus();
              break;
            }
          }
        }
      });
    };
    const focusNext = () => {
      nextTick(() => {
        const elements = getFocusableElements();
        const activeElement = getActiveElement();
        const currentIndex = elements.indexOf(activeElement);
        if (currentIndex < elements.length - 1) {
          for (let i = currentIndex + 1; i < elements.length; i++) {
            if (!isDisabled(elements[i])) {
              elements[i]?.focus();
              break;
            }
          }
        }
      });
    };
    const handleKeyNav = (event) => {
      if (!props.keyNav) return;
      const { code, shiftKey } = event;
      if (code === CODE_LEFT || code === CODE_UP) {
        stopEvent(event);
        if (shiftKey) {
          focusFirst();
        } else {
          focusPrev();
        }
      } else if (code === CODE_RIGHT || code === CODE_DOWN) {
        stopEvent(event);
        if (shiftKey) {
          focusLast();
        } else {
          focusNext();
        }
      } else if (code === CODE_HOME) {
        stopEvent(event);
        focusFirst();
      } else if (code === CODE_END) {
        stopEvent(event);
        focusLast();
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "toolbarRef",
        ref: toolbarRef,
        class: normalizeClass([computedClasses.value, "btn-toolbar"]),
        role: unref(props).role,
        "aria-label": unref(props).ariaLabel,
        onKeydown: handleKeyNav
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 42, _hoisted_1);
    };
  }
});
export {
  _sfc_main$1 as _,
  _sfc_main as a
};
//# sourceMappingURL=BButtonToolbar.vue_vue_type_script_setup_true_lang-CxCcFupr.mjs.map
