import { defineComponent, inject, watch, computed, createBlock, openBlock, withCtx, createElementVNode, mergeProps, createElementBlock, Fragment, renderList, normalizeStyle, normalizeClass, createVNode, TransitionGroup, resolveDynamicComponent, createSlots } from "vue";
import { o as orchestratorRegistryKey } from "./keys-BLeKMItg.mjs";
import { _ as _sfc_main$1 } from "./ConditionalTeleport.vue_vue_type_script_lang-Cp-egLmm.mjs";
const positionClasses = {
  "top-start": "top-0 start-0",
  "top-center": "top-0 start-50 translate-middle-x",
  "top-end": "top-0 end-0",
  "middle-start": "top-50 start-0 translate-middle-y",
  "middle-center": "top-50 start-50 translate-middle",
  "middle-end": "top-50 end-0 translate-middle-y",
  "bottom-start": "bottom-0 start-0",
  "bottom-center": "bottom-0 start-50 translate-middle-x",
  "bottom-end": "bottom-0 end-0"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "BOrchestrator",
  props: {
    noPopovers: { type: Boolean, default: false },
    noToasts: { type: Boolean, default: false },
    noModals: { type: Boolean, default: false },
    appendToast: { type: Boolean, default: false },
    teleportTo: {},
    filter: { type: Function, default: () => true }
  },
  setup(__props) {
    function setEventOk(event) {
      event.ok = event.trigger === "ok" ? true : event.trigger === "cancel" ? false : null;
    }
    const props = __props;
    const orchestratorRegistry = inject(orchestratorRegistryKey);
    if (orchestratorRegistry) {
      if (!orchestratorRegistry._isOrchestratorInstalled.value) {
        orchestratorRegistry._isOrchestratorInstalled.value = true;
      }
    } else {
      if (process.env.NODE_ENV === "development") {
        console.warn(
          "[BOrchestrator] The orchestrator registry not found. Please use BApp, useRegistry or provide the plugin."
        );
      }
    }
    watch(
      () => props.appendToast,
      (value) => {
        if (orchestratorRegistry && value !== void 0) {
          orchestratorRegistry._isToastAppend.value = value;
        }
      },
      { immediate: true }
    );
    const ComputedPositionClasses = computed(() => {
      const positionsActive = items.value?.reduce(
        (acc, item) => {
          if (item.position) {
            acc[item.position] = true;
          }
          return acc;
        },
        {}
      );
      const classes = {};
      for (const position in positionClasses) {
        if (positionsActive?.[position]) {
          classes[position] = {
            class: `${positionClasses[position]} toast-container position-fixed p-3`,
            style: "width: calc(var(--bs-toast-max-width, 350px) + var(--bs-toast-padding-x, 1rem) * 2)"
          };
        }
      }
      if (positionsActive?.["modal"]) {
        classes["modal"] = {
          class: "",
          style: ""
        };
      }
      if (positionsActive?.["popover"]) {
        classes["popover"] = {
          class: "",
          style: ""
        };
      }
      return classes;
    });
    const items = computed(() => {
      const store = orchestratorRegistry?.store.value ?? [];
      return store.filter((el) => !props.noPopovers || el.type !== "popover").filter((el) => !props.noToasts || el.type !== "toast").filter((el) => !props.noModals || el.type !== "modal").filter(props.filter);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$1, {
        to: _ctx.teleportTo,
        disabled: !_ctx.teleportTo
      }, {
        default: withCtx(() => [
          createElementVNode("div", mergeProps({ class: "orchestrator-container" }, _ctx.$attrs), [
            (openBlock(true), createElementBlock(Fragment, null, renderList(ComputedPositionClasses.value, (value, key) => {
              return openBlock(), createElementBlock("div", {
                key,
                class: normalizeClass(value.class),
                style: normalizeStyle(value.style)
              }, [
                createVNode(TransitionGroup, {
                  name: items.value?.filter((el) => el.position === key)?.some((el) => el.type === "toast") ? "b-list" : void 0
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(items.value?.filter((el) => el.position === key) || [], ({
                      _self,
                      type,
                      position,
                      slots,
                      promise,
                      options,
                      _component,
                      ...val
                    }) => {
                      return openBlock(), createElementBlock("span", { key: _self }, [
                        (openBlock(), createBlock(resolveDynamicComponent(_component), mergeProps({ ref_for: true }, val, {
                          ref_for: true,
                          ref: (ref) => promise.value.ref = ref,
                          "initial-animation": "",
                          "teleport-disabled": true,
                          onHide: (e) => {
                            setEventOk(e);
                            val.onHide?.(e);
                            if (e.defaultPrevented) {
                              return;
                            }
                            promise.stop?.();
                            if (options?.resolveOnHide) {
                              promise.resolve(e);
                            }
                          },
                          onHidden: (e) => {
                            setEventOk(e);
                            val.onHidden?.(e);
                            if (e.defaultPrevented) {
                              return;
                            }
                            if (!options?.resolveOnHide) {
                              promise.resolve(e);
                            }
                            if (!options?.keep) {
                              promise.value.destroy?.();
                            }
                          }
                        }), createSlots({ _: 2 }, [
                          renderList(slots, (comp, slot) => {
                            return {
                              name: slot,
                              fn: withCtx((scope) => [
                                (openBlock(), createBlock(resolveDynamicComponent(comp), mergeProps({ ref_for: true }, scope), null, 16))
                              ])
                            };
                          })
                        ]), 1040, ["onHide", "onHidden"]))
                      ]);
                    }), 128))
                  ]),
                  _: 2
                }, 1032, ["name"])
              ], 6);
            }), 128))
          ], 16)
        ]),
        _: 1
      }, 8, ["to", "disabled"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=BOrchestrator.vue_vue_type_script_setup_true_lang-Dz_rJ4Bq.mjs.map
