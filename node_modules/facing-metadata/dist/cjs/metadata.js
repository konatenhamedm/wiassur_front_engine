"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Metadata_instances, _Metadata_travel;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Metadata = void 0;
const error_1 = require("./error");
class Metadata {
    /**
     * Metadata.
     * @param symbol Optional. Signature for this metadata. It will be set as the key in the target.
     */
    constructor(symbol = Symbol('faple-metadata')) {
        _Metadata_instances.add(this);
        this.symbol = symbol;
    }
    /**
     * Create metadata in the target.
     * @param target Target.
     * @param data   Init metadata.
     */
    create(target, data) {
        if (Object.getOwnPropertyDescriptor(target, this.symbol)) {
            (0, error_1.error)('Target had metadata');
        }
        Object.defineProperty(target, this.symbol, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: data
        });
    }
    /**
     * Get own metadata.
     * @param target Target.
     * @returns Metadata data or undefined.
     */
    getOwn(target) {
        const des = Object.getOwnPropertyDescriptor(target, this.symbol);
        if (!des) {
            return undefined;
        }
        return des.value;
    }
    /**
    * Get metadata in prototype chain.
    * @param target Target.
    * @returns Metadata data or undefined.
    */
    get(target) {
        let data = undefined;
        __classPrivateFieldGet(this, _Metadata_instances, "m", _Metadata_travel).call(this, target, (target, _data) => {
            data = _data;
            return false;
        });
        return data;
    }
    /**
     * Get metadata array in prototype chain.
     * @param target Target.
     * @returns Metadata array to acient.
     */
    getAll(target) {
        let data = [];
        __classPrivateFieldGet(this, _Metadata_instances, "m", _Metadata_travel).call(this, target, (target, _data) => {
            data.push(_data);
            return true;
        });
        return data;
    }
    /**
     * Set value in the own mdatadata.
     * Implement by `obtainOwn`.
     * @param target Target.
     * @param key Key.
     * @param value value.
     */
    setValueOwn(target, key, value) {
        const _data = this.getOwn(target);
        if (!_data) {
            (0, error_1.error)('Target has not metadata');
        }
        _data[key] = value;
    }
    /**
    * Set value in the recent mdatadata in prototype chain.
    * Implement by `obtain`.
    * @param target Target.
    * @param key Key.
    * @param value value.
    */
    setValue(target, key, value) {
        const _data = this.get(target);
        if (!_data) {
            (0, error_1.error)('Target has not metadata');
        }
        _data[key] = value;
    }
    /**
     * Get value in the own metadata.
     * @param target Target.
     * @param key Key.
     * @returns
     */
    getValueOwn(target, key) {
        const data = this.getOwn(target);
        if (data === undefined) {
            (0, error_1.error)('Target has not metadata');
        }
        return data[key];
    }
    /**
    * Get value in the recent mdatadata WHICH HAS THE KEY in prototype chain.
    * @param target Target.
    * @param key Key.
    */
    getValue(target, key) {
        let foundMetadata = false;
        let value = undefined;
        __classPrivateFieldGet(this, _Metadata_instances, "m", _Metadata_travel).call(this, target, (target, _data) => {
            foundMetadata = true;
            if (!(key in _data) || _data[key] === undefined) {
                return true;
            }
            value = _data[key];
            return false;
        });
        if (!foundMetadata) {
            (0, error_1.error)('Target has not metadata');
        }
        return value;
    }
}
exports.Metadata = Metadata;
_Metadata_instances = new WeakSet(), _Metadata_travel = function _Metadata_travel(target, traveler) {
    let t = target;
    do {
        const data = this.getOwn(t);
        if (data !== undefined) {
            if (!traveler(target, data)) {
                break;
            }
        }
        t = Object.getPrototypeOf(t);
    } while (t !== null);
};
//# sourceMappingURL=metadata.js.map