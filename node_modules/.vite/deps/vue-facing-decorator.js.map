{
  "version": 3,
  "sources": ["../../facing-metadata/src/error.ts", "../../facing-metadata/src/metadata.ts", "../../vue-facing-decorator/src/slot.ts", "../../vue-facing-decorator/src/deco3/utils.ts", "../../vue-facing-decorator/src/class.ts", "../../vue-facing-decorator/src/utils.ts", "../../vue-facing-decorator/src/option/setup.ts", "../../vue-facing-decorator/src/option/computed.ts", "../../vue-facing-decorator/src/option/data.ts", "../../vue-facing-decorator/src/option/methodsAndHooks.ts", "../../vue-facing-decorator/src/optionBuilder.ts", "../../vue-facing-decorator/src/option/ref.ts", "../../vue-facing-decorator/src/option/watch.ts", "../../vue-facing-decorator/src/option/props.ts", "../../vue-facing-decorator/src/option/inject.ts", "../../vue-facing-decorator/src/option/provide.ts", "../../vue-facing-decorator/src/option/emit.ts", "../../vue-facing-decorator/src/option/vmodel.ts", "../../vue-facing-decorator/src/option/accessor.ts", "../../vue-facing-decorator/src/component.ts", "../../vue-facing-decorator/src/option/vanilla.ts", "../../vue-facing-decorator/src/custom/custom.ts", "../../vue-facing-decorator/src/mixins.ts", "../../vue-facing-decorator/src/tsx/type.ts"],
  "sourcesContent": ["export function error(str: string): never {\n    throw `facing-metadata: ${str}`\n}", "import { error } from './error'\n\nexport class Metadata<T extends {\n    [index: string | number | symbol]: any\n}> {\n    symbol: symbol\n    /**\n     * Metadata.\n     * @param symbol Optional. Signature for this metadata. It will be set as the key in the target.\n     */\n    constructor(symbol = Symbol('faple-metadata')) {\n        this.symbol = symbol\n    }\n\n    /**\n     * Create metadata in the target.\n     * @param target Target.\n     * @param data   Init metadata.\n     */\n    create(target: any, data: T) {\n        if (Object.getOwnPropertyDescriptor(target, this.symbol)) {\n            error('Target had metadata')\n        }\n        Object.defineProperty(target, this.symbol, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: data\n        })\n    }\n\n    #travel(target: any, traveler: { (target: any, data: T): boolean }) {\n        let t = target\n        do {\n            const data = this.getOwn(t)\n            if (data !== undefined) {\n                if (!traveler(target, data)) {\n                    break\n                }\n\n            }\n            t = Object.getPrototypeOf(t)\n        } while (t !== null)\n    }\n    /**\n     * Get own metadata.\n     * @param target Target.\n     * @returns Metadata data or undefined.\n     */\n    getOwn(target: any): T | undefined {\n        const des = Object.getOwnPropertyDescriptor(target, this.symbol)\n        if (!des) {\n            return undefined\n        }\n        return des.value\n    }\n    /**\n    * Get metadata in prototype chain.\n    * @param target Target.\n    * @returns Metadata data or undefined.\n    */\n    get(target: any): T | undefined {\n        let data: T | undefined = undefined\n        this.#travel(target, (target, _data) => {\n            data = _data\n            return false\n        })\n        return data\n    }\n    /**\n     * Get metadata array in prototype chain.\n     * @param target Target.\n     * @returns Metadata array to acient.\n     */\n    getAll(target: any): T[] {\n        let data: T[] = []\n        this.#travel(target, (target, _data) => {\n            data.push(_data)\n            return true\n        })\n        return data\n    }\n    /**\n     * Set value in the own mdatadata.\n     * Implement by `obtainOwn`.\n     * @param target Target.\n     * @param key Key.\n     * @param value value.\n     */\n    setValueOwn<K extends keyof T>(target: any, key: K, value: T[K]) {\n        const _data = this.getOwn(target)\n        if (!_data) {\n            error('Target has not metadata')\n        }\n        _data[key] = value\n    }\n    /**\n    * Set value in the recent mdatadata in prototype chain.\n    * Implement by `obtain`.\n    * @param target Target.\n    * @param key Key.\n    * @param value value.\n    */\n    setValue<K extends keyof T>(target: any, key: K, value: T[K]) {\n        const _data = this.get(target)\n        if (!_data) {\n            error('Target has not metadata')\n        }\n        _data[key] = value\n    }\n    /**\n     * Get value in the own metadata.\n     * @param target Target.\n     * @param key Key.\n     * @returns \n     */\n    getValueOwn<K extends keyof T>(target: any, key: K) {\n        const data = this.getOwn(target)\n        if (data === undefined) {\n            error('Target has not metadata')\n        }\n        return data[key]\n    }\n    /**\n    * Get value in the recent mdatadata WHICH HAS THE KEY in prototype chain.\n    * @param target Target.\n    * @param key Key.\n    */\n    getValue<K extends keyof T>(target: any, key: K) {\n        let foundMetadata = false\n        let value: T[K] | undefined = undefined\n        this.#travel(target, (target, _data) => {\n            foundMetadata = true\n            if (!(key in _data) || _data[key] === undefined) {\n                return true\n            }\n            value = _data[key]\n            return false\n        })\n        if (!foundMetadata) {\n            error('Target has not metadata')\n        }\n        return value as T[K]\n    }\n}\n", "import { Metadata } from 'facing-metadata'\nimport type { InjectConfig } from \"./option/inject\";\nimport type { EmitConfig } from \"./option/emit\";\nimport type { PropsConfig } from \"./option/props\";\nimport type { HookConfig } from \"./option/methodsAndHooks\";\nimport type { VModelConfig } from \"./option/vmodel\";\nimport type { WatchConfig } from \"./option/watch\";\nimport type { SetupConfig } from './option/setup'\nimport type { Record as CustomDecoratorRecord } from './custom/custom'\nimport type { RefConfig } from './option/ref';\nimport type { ProvideConfig } from './option/provide';\n\nconst SlotSymbol: unique symbol = Symbol('vue-facing-decorator-slot')\n\nexport type SlotMapTypes = {\n    vanilla: Map<string, boolean>\n    computed: Map<string, boolean>\n    provide: Map<string, ProvideConfig>\n    inject: Map<string, InjectConfig>\n    emit: Map<string, EmitConfig>\n    emits: Map<string, boolean>\n    props: Map<string, PropsConfig>\n    hooks: Map<string, HookConfig>\n    'v-model': Map<string, VModelConfig>\n    watch: Map<string, WatchConfig | WatchConfig[]>\n    ref: Map<string, RefConfig>\n    setup: Map<string, SetupConfig>\n    customDecorator: Map<string, CustomDecoratorRecord[]>\n}\n\nexport type SlotMapNames = keyof SlotMapTypes\n\nexport class Slot {\n    master: any\n    constructor(master: any) {\n        this.master = master\n    }\n    names: Map<keyof SlotMapTypes, SlotMapTypes[keyof SlotMapTypes]> = new Map()\n    obtainMap<T extends keyof SlotMapTypes>(name: T): SlotMapTypes[T] {\n        let map = this.getMap(name)\n        if (!map) {\n            map = new Map()\n            this.names.set(name, map)\n        }\n        return map as SlotMapTypes[T]\n    }\n    getMap<T extends keyof SlotMapTypes>(name: T) {\n        const map = this.names.get(name)\n        return map as SlotMapTypes[T] | undefined\n    }\n    inComponent = false\n    cachedVueComponent: any = null\n}\n\nconst metadata = new Metadata<Slot>(SlotSymbol)\n\nexport function makeSlot(obj: any, defaultSlot?: Slot): Slot {\n    if (getSlot(obj)) {\n        throw ''\n    }\n    if (defaultSlot) {\n        defaultSlot.master = obj\n    }\n    const slot = defaultSlot ?? new Slot(obj)\n    metadata.create(obj, slot)\n    return slot\n}\n\nexport function getSlot(obj: any): Slot | undefined {\n    return metadata.getOwn(obj)\n}\n\nexport function obtainSlot(obj: any, defaultSlot?: Slot): Slot {\n\n    const slot = getSlot(obj)\n    if (slot) {\n        return slot\n    }\n\n    return makeSlot(obj, defaultSlot)\n}", "import { VueCons } from '../class'\nimport { obtainSlot } from '../slot'\nexport const Compatible: {\n    fakePrototype?: any,\n\n} = {\n\n}\nexport function compatibleClassDecorator(deco: Function) {\n    return function (cons: VueCons, ctx?: ClassDecoratorContext) {\n        if (ctx) {//stage 3 arg is constructor, ctx is ClassDecoratorContext\n            if (ctx.kind !== 'class') {\n                throw 'deco stage 3 class'\n            }\n            const proto = Compatible.fakePrototype ??= {}\n            const slot = obtainSlot(proto)\n            delete Compatible.fakePrototype\n\n            obtainSlot(cons.prototype, slot)\n            const ret = deco(cons)\n\n            return ret\n        }\n        else {//stage 2 arg is constructor\n            return deco(cons)\n        }\n    }\n}\n\nexport function compatibleMemberDecorator(deco: Function) {\n    return function (protoOrValue: any, nameOrCtx: ClassMemberDecoratorContext | string) {\n        if (typeof nameOrCtx === 'object') {//stage 3 arg is value, ctx is ClassMemberDecoratorContext\n            const ctx = nameOrCtx\n            const value = protoOrValue\n            const proto = Compatible.fakePrototype ??= {};\n            proto[ctx.name!] = value\n            return deco(proto, ctx.name)\n        } else { //stage 2 arg is prototype, ctx is name stirng\n            const name = nameOrCtx\n            const proto = protoOrValue\n            return deco(proto, name)\n        }\n    }\n}", "import type { ComponentPublicInstance } from 'vue'\nimport type { IdentityType, Identity,IdentityAny, IdentitySymbol } from './identity'\nexport type VueCons<RawInstance extends Identity = Identity, IT extends IdentityType = { props: {}, events: {} }, Bundle = IT['props'] & { [index in keyof IT['events']as `on${Capitalize<index & string>}`]?: IT['events'][index] extends Function ? IT['events'][index] : { (param: IT['events'][index]): any } }> = {\n    new(): ComponentPublicInstance<Bundle> & Identity<IT> & Omit<RawInstance, typeof IdentitySymbol>\n}\n\nexport type VueConsAny<RawInstance extends Identity = Identity, IT extends IdentityType = { props: {}, events: {} }, Bundle = IT['props'] & { [index in keyof IT['events']as `on${Capitalize<index & string>}`]?: IT['events'][index] extends Function ? IT['events'][index] : { (param: IT['events'][index]): any } }> = {\n    new(): ComponentPublicInstance<Bundle> & IdentityAny<IT> & Omit<RawInstance, typeof IdentitySymbol> & { [index: PropertyKey]: any }\n}\n\nexport const Base = class {\n\n} as VueCons", "import type { IdentityAny } from './identity'\nimport { compatibleMemberDecorator, compatibleClassDecorator } from './deco3/utils';\nimport { type VueCons, Base } from './class';\nimport { getSlot, type Slot, type SlotMapNames } from './slot'\n\nexport function getPrototypeOf(proto: IdentityAny): IdentityAny | null {\n    const p = Object.getPrototypeOf(proto)\n    if (!(p instanceof Base)) {\n        return null\n    }\n    return p\n}\n\nexport function toComponentReverse(proto: IdentityAny) {\n    const arr: IdentityAny[] = []\n    let curr: IdentityAny | null = proto\n    do {\n        arr.unshift(curr)\n        curr = getPrototypeOf(curr)\n    } while (curr !== null && !getSlot(curr))\n    return arr\n}\n\nexport function getSuperSlot(proto: IdentityAny) {\n    let curr = getPrototypeOf(proto)\n\n    while (curr !== null) {\n        const slot = getSlot(curr)\n        if (slot) {\n            return slot\n        }\n        curr = getPrototypeOf(curr)\n    }\n    return null\n}\n\n/**\n * Filter decorated names\n */\nexport function filterNames(names: string[], slot: Slot, mapNames?: SlotMapNames[]) {\n    return names.filter(name => {\n        let currSlot: Slot | null = slot\n        while (currSlot != null) {\n            for (const mapName of currSlot.names.keys()) {\n                if (mapName === 'customDecorator') {\n                    const map = currSlot.obtainMap('customDecorator')\n                    if (map.has(name)) {\n                        if (map.get(name)!.every(ite => !ite.preserve)) {\n                            return false\n                        }\n                    }\n                }\n                if (mapNames && mapNames.includes(mapName)) {\n                    continue\n                }\n\n                const map = currSlot.names.get(mapName)!\n                if (map.has(name)) {\n                    return false\n                }\n            }\n            currSlot = getSuperSlot(currSlot.master)\n        }\n\n        return true\n    })\n}\n\n/**\n * Get own propertie name by a filter\n */\nexport function getValidOwnPropertyNames(obj: any, filter: (des: PropertyDescriptor, name: string) => boolean) {\n    const descriptors = Object.getOwnPropertyDescriptors(obj)\n    return Object.keys(descriptors).filter(name => filter(descriptors[name], name))\n}\n\n\n/**\n * Transform provide into function.\n */\nexport function getProviderFunction(provide: any): () => {} {\n    if (typeof provide === 'function') return provide\n    return function () { return provide || {} }\n}\n\nexport function optionNullableMemberDecorator<T>(handler: { (proto: any, name: string, option?: T): any }) {\n    function decorator(): any\n    function decorator(option: T): any//option\n    function decorator(proto: IdentityAny, name: any): any//deco stage 2\n    function decorator(value: any, ctx: ClassMemberDecoratorContext): any //deco stage 3\n    function decorator(optionOrProtoOrValue?: T | IdentityAny | any, nameOrCtx?: string | ClassMemberDecoratorContext): any {\n        if (nameOrCtx) {//no option\n            const protoOrValue = optionOrProtoOrValue as IdentityAny | any\n            compatibleMemberDecorator(function (proto: any, name: any) {\n                handler(proto, name)\n            })(protoOrValue, nameOrCtx)\n        }\n        else {//with option\n            const option = optionOrProtoOrValue as T\n            return compatibleMemberDecorator(function (proto: any, name: any) {\n                handler(proto, name, option as T | undefined)\n            })\n        }\n    }\n\n    return decorator\n}\n\nexport function optionNullableClassDecorator<T>(handler: { (cons: VueCons, option?: T): any }) {\n    function decorator(): any\n    function decorator(option: T): any//option\n    function decorator(cons: VueCons): any//deco stage 2\n    function decorator(cons: VueCons, ctx: ClassDecoratorContext): any//deco stage 3\n    function decorator(optionOrCons?: T | VueCons, ctx?: ClassDecoratorContext) {\n        if (typeof optionOrCons === 'function') {\n            const cons = optionOrCons as VueCons\n            compatibleClassDecorator(function (cons: VueCons) {\n                handler(cons)\n            })(cons, ctx)\n\n        } else {\n            const option = optionOrCons as T\n            return compatibleClassDecorator(function (cons: VueCons) {\n                handler(cons, option)\n            })\n        }\n    }\n    return decorator\n}\n\n", "import { compatibleMemberDecorator } from '../deco3/utils'\nimport type { OptionSetupFunction } from '../component'\nimport type { VueCons } from '../class'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { obtainSlot } from '../slot'\n\nexport type SetupConfig = {\n    setupFunction: OptionSetupFunction\n}\n\nexport function decorator(setupFunction: OptionSetupFunction) {\n    return compatibleMemberDecorator(function (proto: any, name: string) {\n        const slot = obtainSlot(proto)\n        const map = slot.obtainMap('setup')\n        map.set(name, {\n            setupFunction\n        })\n    })\n}\n\nconst isPromise = (v: any): v is Promise<any> => v instanceof Promise\n\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\n    const slot = obtainSlot(cons.prototype)\n    const map = slot.getMap('setup')\n    if (!map || map.size === 0) {\n        return\n    }\n    const setup: OptionSetupFunction = function (props, ctx) {\n\n        const setupData: Record<string, any> = {};\n        let promises: Promise<any>[] | null = null;\n        for (const name of map.keys()) {\n\n            const setupState = map.get(name)!.setupFunction(props, ctx)\n\n            if (isPromise(setupState)) {\n                promises ??= []\n                promises.push(setupState.then((v) => {\n                    setupData[name] = v\n                }))\n            } else {\n                setupData[name] = setupState\n            }\n        }\n        if (Array.isArray(promises)) {\n            return Promise.all(promises).then(() => {\n                return setupData\n            })\n        } else {\n            return setupData\n        }\n    }\n\n    optionBuilder.setup = setup\n}\n", "import type { VueCons } from '../class'\nimport { toComponentReverse, getValidOwnPropertyNames } from '../utils'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { obtainSlot } from '../slot'\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\n    optionBuilder.computed ??= {}\n    const slot = obtainSlot(cons.prototype)\n    const map = slot.obtainMap('computed')\n    const vanillaMap = slot.obtainMap('vanilla')\n    const protoArr = toComponentReverse(cons.prototype)\n    protoArr.forEach(proto => {\n        getValidOwnPropertyNames(proto, (des, name) => {\n            return (typeof des.get === 'function' || typeof des.set === 'function') && !vanillaMap.has(name)\n        }).forEach(name => {\n\n            map.set(name, true)\n            const des = Object.getOwnPropertyDescriptor(proto, name)!\n            optionBuilder.computed![name] = {\n                get: typeof des.get === 'function' ? des.get : undefined,\n                set: typeof des.set === 'function' ? des.set : undefined\n            }\n        })\n    })\n}\n", "import type { VueConsAny } from '../class'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { filterNames, getValidOwnPropertyNames } from '../utils'\nimport { obtainSlot } from '../slot'\nexport function build(cons: VueConsAny, optionBuilder: OptionBuilder) {\n    optionBuilder.data ??= {}\n    const sample = new cons()\n    let names = getValidOwnPropertyNames(sample, (des, name) => {\n        return !!des.enumerable\n            && !optionBuilder.methods?.[name]\n            && !optionBuilder.props?.[name]\n    })\n    const slot = obtainSlot(cons.prototype)\n    //include these names:\n    //provide, user may access field directly\n    //customDecorator\n    names = filterNames(names, slot, ['provide', 'customDecorator'])\n    Object.assign(optionBuilder.data,\n        names.reduce<Record<string, any>>((pv, cv) => {\n            pv[cv] = sample[cv]\n            return pv\n        }, {})\n    )\n}\n", "import type { VueConsAny } from '../class'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { toComponentReverse, filterNames, getValidOwnPropertyNames, optionNullableMemberDecorator } from '../utils'\nimport { obtainSlot } from '../slot'\nexport const HookNames: ReadonlyArray<string> = [\n    \"beforeCreate\",\n    \"created\",\n    \"beforeMount\",\n    \"mounted\",\n    \"beforeUpdate\",\n    \"updated\",\n    \"activated\",\n    \"deactivated\",\n    \"beforeDestroy\",\n    \"beforeUnmount\",\n    \"destroyed\",\n    \"unmounted\",\n    \"renderTracked\",\n    \"renderTriggered\",\n    \"errorCaptured\",\n    \"serverPrefetch\",\n    \"render\"\n] as const\n\nexport type HookConfig = null\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('hooks');\n    map.set(name, null)\n})\n\nexport function build(cons: VueConsAny, optionBuilder: OptionBuilder) {\n    const slot = obtainSlot(cons.prototype)\n    const protoArr = toComponentReverse(cons.prototype)\n    const map = slot.obtainMap('hooks')\n\n    optionBuilder.hooks ??= {}\n    optionBuilder.methods ??= {}\n    const HookFunctions: Record<string, Function> = {}\n    const MethodFunctions: Record<string, Function> = {}\n    protoArr.forEach(proto => {\n        let names = getValidOwnPropertyNames(proto, (des, name) => {\n            return typeof des.value === 'function' && name !== 'constructor'\n        })\n        //include these names:\n        //watch, user may call watch method directly\n        //hooks, user may call hook method directly\n        //emits, user may have a method name which is same as one of event names\n        //provide, user may access field directly\n        //customDecorator\n        names = filterNames(names, slot, ['watch', 'hooks', 'emits', 'provide', 'customDecorator']);\n        names.forEach(name => {\n            if (HookNames.includes(name) || map.has(name)) {\n                HookFunctions[name] = proto[name]\n            } else {\n                MethodFunctions[name] = proto[name]\n            }\n        })\n    })\n\n    Object.assign(optionBuilder.methods, MethodFunctions)\n    const beforeCreateCallbacks = [...optionBuilder.beforeCreateCallbacks ?? []]\n    if (beforeCreateCallbacks && beforeCreateCallbacks.length > 0) {\n        const oldBeforeCreateCallback = HookFunctions['beforeCreate']\n        HookFunctions['beforeCreate'] = function () {\n            beforeCreateCallbacks.forEach(callback => callback.apply(this, arguments))\n            if (oldBeforeCreateCallback) {\n                oldBeforeCreateCallback.apply(this, arguments)\n            }\n        }\n    }\n    Object.assign(optionBuilder.hooks, HookFunctions)\n}\n", "import type { WatchConfig } from './option/watch'\nimport type { PropsConfig } from './option/props'\nimport type { InjectConfig } from './option/inject'\nimport type { OptionSetupFunction } from './component'\nexport interface OptionBuilder {\n    name?: string\n    // setup?: (this: void, props: Readonly<any>, ctx: SetupContext<any>) => Promise<any> | any | RenderFunction | void\n    data?: Record<string, any>\n    methods?: Record<string, Function>\n    hooks?: Record<string, Function>\n    computed?: Record<string, any>\n    watch?: Record<string, WatchConfig | WatchConfig[]>\n    props?: Record<string, PropsConfig>\n    provide?: Record<string, any>\n    inject?: Record<string, InjectConfig>\n    setup?: OptionSetupFunction\n    beforeCreateCallbacks?: Function[]\n}\n\nexport function applyAccessors(optionBuilder: OptionBuilder, dataFunc: (ctx: any) => Map<string, { get: (() => any) | undefined, set: ((v: any) => any) | undefined }>) {\n    optionBuilder.beforeCreateCallbacks ??= []\n    optionBuilder.beforeCreateCallbacks.push(function (this: any) {\n        const ctx = this\n        const data = dataFunc(ctx)\n        data.forEach((v, n) => {\n            Object.defineProperty(ctx, n, v)\n        })\n    })\n}\n", "import type { VueCons } from '../class'\nimport { type OptionBuilder, applyAccessors } from '../optionBuilder'\nimport { optionNullableMemberDecorator } from '../utils'\nimport { obtainSlot } from '../slot'\nexport type RefConfig = null | string\n\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, key?: string) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('ref')\n    map.set(name, typeof key === 'undefined' ? null : key)\n})\n\n\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\n    const slot = obtainSlot(cons.prototype)\n\n    const names = slot.getMap('ref')\n    if (!names || names.size === 0) {\n        return\n    }\n\n    applyAccessors(optionBuilder, (ctx: any) => {\n        const data: Map<string, { get: () => any, set: undefined }> = new Map\n        names.forEach((value, name) => {\n            const refKey = value === null ? name : value\n            data.set(name, {\n                get: function (this: any) {\n                    return ctx.$refs[refKey]\n                },\n                set: undefined\n\n            })\n        })\n        return data\n    })\n\n}\n", "import type { VueCons } from '../class'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { obtainSlot } from '../slot'\nimport type { WatchCallback } from 'vue'\nimport { compatibleMemberDecorator } from '../deco3/utils'\nexport interface WatchConfig {\n    key: string\n    handler: WatchCallback,\n    flush?: 'post',\n    deep?: boolean,\n    immediate?: boolean,\n}\ntype Option = Omit<WatchConfig, 'handler' | 'key'>\nexport function decorator(key: string, option?: Option) {\n    return compatibleMemberDecorator(function (proto: any, name: string) {\n        const slot = obtainSlot(proto)\n        const map = slot.obtainMap('watch');\n        const opt = Object.assign({}, option ?? {}, {\n            key: key,\n            handler: proto[name]\n        })\n        if (map.has(name)) {\n            const t = map.get(name)!\n            if (Array.isArray(t)) {\n                t.push(opt)\n            } else {\n                map.set(name, [t, opt])\n            }\n        }\n        else {\n            map.set(name, opt)\n        }\n    })\n}\n\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\n    optionBuilder.watch ??= {}\n    const slot = obtainSlot(cons.prototype)\n    const names = slot.getMap('watch')\n    if (!names || names.size === 0) {\n        return\n    }\n\n    names.forEach((value, _name) => {\n        const values = Array.isArray(value) ? value : [value]\n        values.forEach(v => {\n            if (!optionBuilder.watch![v.key]) {\n                optionBuilder.watch![v.key] = v\n            } else {\n                const t = optionBuilder.watch![v.key]\n                if (Array.isArray(t)) {\n                    t.push(v)\n                } else {\n                    optionBuilder.watch![v.key] = [t, v]\n                }\n            }\n        })\n    })\n\n\n}\n", "import type { VueCons } from '../class'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { optionNullableMemberDecorator } from '../utils'\nimport { obtainSlot } from '../slot'\nexport interface PropsConfig {\n    type?: any\n    required?: boolean\n    default?: any\n    validator?(value: any): boolean;\n}\n\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, option?: PropsConfig) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('props')\n    const opt = Object.assign({}, option ?? {})\n    map.set(name, opt as PropsConfig)\n})\n\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\n    optionBuilder.props ??= {}\n    const slot = obtainSlot(cons.prototype)\n    const names = slot.getMap('props')\n    if (!names || names.size === 0) {\n        return\n    }\n\n    names.forEach((value, name) => {\n        optionBuilder.props![name] = value\n    })\n\n\n}\n\n\n", "import type { InjectionKey } from 'vue'\nimport type { VueCons } from '../class'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { optionNullableMemberDecorator } from '../utils'\nimport { obtainSlot } from '../slot'\nexport interface InjectConfig {\n    from?: string | symbol | Symbol | InjectionKey<any>\n    default?: any\n}\n\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, option?: InjectConfig) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('inject')\n    const opt = Object.assign({}, option ?? {})\n    map.set(name, opt)\n})\n\n\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\n    optionBuilder.inject ??= {}\n    const slot = obtainSlot(cons.prototype)\n    const names = slot.getMap('inject')\n    if (!names || names.size === 0) {\n        return\n    }\n\n    names.forEach((value, name) => {\n        optionBuilder.inject![name] = value\n    })\n\n}\n\n\n", "import { computed } from 'vue';\nimport type { VueCons } from '../class';\nimport type { OptionBuilder } from '../optionBuilder'\nimport { optionNullableMemberDecorator } from '../utils'\nimport { obtainSlot } from '../slot'\nexport type ProvideConfig = null | string\n\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, key?: ProvideConfig) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('provide')\n    map.set(name, typeof key === 'undefined' ? null : key)\n})\n\nexport function build(cons: VueCons, optionBuilder: OptionBuilder, vueInstance: any) {\n    optionBuilder.provide ??= {}\n    const slot = obtainSlot(cons.prototype)\n    const names = slot.obtainMap('provide')\n    if (!names) return null\n    names.forEach((value, name) => {\n        const key = value === null ? name : value\n        optionBuilder.provide![key] = computed(() => vueInstance[name])\n    })\n}\n", "import type { VueCons } from '../class'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { optionNullableMemberDecorator } from '../utils'\nexport type EmitConfig = null | string\nimport { obtainSlot } from '../slot'\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, key?: string) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('emit');\n    map.set(name, typeof key === 'undefined' ? null : key)\n})\n\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\n    optionBuilder.methods ??= {}\n    const proto = cons.prototype\n    const slot = obtainSlot(proto)\n    const names = slot.getMap('emit')\n    if (!names || names.size === 0) {\n        return\n    }\n    const emits = slot.obtainMap('emits')\n    names.forEach((value, key) => {\n        const eventName = value === null ? key : value\n        emits.set(eventName, true)\n        optionBuilder.methods![key] = async function (this: any) {\n\n            const ret = proto[key].apply(this, arguments)\n            if (ret instanceof Promise) {\n                const proRet = await ret\n                this.$emit(eventName, proRet)\n            }\n            else if (ret === undefined) {\n                this.$emit(eventName)\n            } else {\n                this.$emit(eventName, ret)\n            }\n        }\n    })\n\n}\n", "import type { VueCons } from '../class'\nimport type { OptionBuilder } from '../optionBuilder'\nimport {  optionNullableMemberDecorator } from '../utils'\nimport { decorator as PropsDecorator, type PropsConfig } from './props'\nimport { obtainSlot } from '../slot'\nexport type VModelConfig = PropsConfig & {\n    name?: string\n}\n\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, option?: VModelConfig) {\n    option ??= {}\n    const slot = obtainSlot(proto)\n    let vmodelName = 'modelValue'\n    const propsConfig = { ...option }\n    if (propsConfig) {\n        vmodelName = propsConfig.name ?? vmodelName\n        delete propsConfig.name\n    }\n    PropsDecorator(propsConfig)(proto, vmodelName)\n    const map = slot.obtainMap('v-model')\n    map.set(name, option)\n})\n\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\n    optionBuilder.computed ??= {}\n    const slot = obtainSlot(cons.prototype)\n    const names = slot.getMap('v-model')\n    if (!names || names.size === 0) {\n        return\n    }\n    const emits = slot.obtainMap('emits')\n\n    names.forEach((value, name) => {\n        const vmodelName = (value && value.name) ?? 'modelValue'\n        const eventName = `update:${vmodelName}`\n        optionBuilder.computed![name] = {\n            get: function (this: any) {\n                return this[vmodelName]\n            },\n            set: function (val: any) {\n                this.$emit(eventName, val)\n            }\n        }\n        emits.set(eventName, true)\n    })\n\n}\n", "import type { VueCons } from '../class'\nimport { type OptionBuilder, applyAccessors } from '../optionBuilder'\nimport { toComponentReverse } from '../utils'\nimport { obtainSlot } from '../slot'\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\n    const slot = obtainSlot(cons.prototype)\n    const vanillaMap = slot.getMap('vanilla')\n    if (!vanillaMap || vanillaMap.size === 0) {\n        return\n    }\n    const protoArr = toComponentReverse(cons.prototype)\n    const map: Map<string, { get: (() => any) | undefined, set: ((v: any) => any) | undefined }> | undefined = new Map\n\n    applyAccessors(optionBuilder, (ctx: any) => {\n        protoArr.forEach(proto => {\n            const deses = Object.getOwnPropertyDescriptors(proto)\n            for (const name in deses) {\n                const des = deses[name]\n                if (des && vanillaMap.has(name)) {\n                    if (typeof des.get === 'function' || typeof des.set === 'function') {\n                        map.set(name, {\n                            set: typeof des.set === 'function' ? des.set.bind(ctx) : undefined,\n                            get: typeof des.get === 'function' ? des.get.bind(ctx) : undefined,\n                        })\n                    }\n                }\n            }\n        })\n        return map\n    })\n}\n", "import { defineComponent, type ComponentCustomOptions, type MethodOptions } from 'vue';\nimport { obtainSlot } from './slot'\nimport { getSuperSlot, getProviderFunction, optionNullableClassDecorator } from './utils'\nimport { build as optionSetup } from './option/setup'\nimport { build as optionComputed } from './option/computed'\nimport { build as optionData } from './option/data'\nimport { build as optionMethodsAndHooks } from './option/methodsAndHooks'\nimport { build as optionRef } from './option/ref'\nimport { build as optionWatch } from './option/watch'\nimport { build as optionProps } from './option/props'\nimport { build as optionInject } from './option/inject'\nimport { build as optionProvide } from './option/provide'\nimport { build as optionEmit } from './option/emit'\nimport { build as optionVModel } from './option/vmodel'\nimport { build as optionAccessor } from './option/accessor'\nimport type { SetupContext } from 'vue';\nimport type { OptionBuilder } from './optionBuilder'\nimport type { VueCons } from './class'\ntype SetupFunction<T> = (this: void, props: Readonly<any>, ctx: SetupContext<any>) => T | Promise<T>\nexport type OptionSetupFunction = SetupFunction<any>\nexport type ComponentSetupFunction = SetupFunction<Record<string, any>>\nfunction componentOptionFactory(cons: VueCons, extend?: any) {\n    const optionBuilder: OptionBuilder = {}\n    optionSetup(cons, optionBuilder)\n    optionVModel(cons, optionBuilder)\n    optionComputed(cons, optionBuilder)//after VModel\n    optionWatch(cons, optionBuilder)\n    optionProps(cons, optionBuilder)\n    optionInject(cons, optionBuilder)\n    optionEmit(cons, optionBuilder)\n    optionRef(cons, optionBuilder)//after Computed\n    optionAccessor(cons, optionBuilder)\n    optionMethodsAndHooks(cons, optionBuilder)//the last one\n    const raw = {\n        name: cons.name,\n        setup: optionBuilder.setup,\n        data() {\n            delete optionBuilder.data\n            optionData(cons, optionBuilder)\n            return optionBuilder.data ?? {}\n        },\n        methods: optionBuilder.methods,\n        computed: optionBuilder.computed,\n        watch: optionBuilder.watch,\n        props: optionBuilder.props,\n        inject: optionBuilder.inject,\n        provide() {\n            optionProvide(cons, optionBuilder, this)\n            return optionBuilder.provide ?? {}\n        },\n        ...optionBuilder.hooks,\n        extends: extend\n    }\n    return raw as any\n}\n\ntype ComponentOption = {\n    name?: string\n    emits?: string[]\n    provide?: Record<string, any> | Function\n    components?: Record<string, any>\n    directives?: Record<string, any>;\n    inheritAttrs?: boolean;\n    expose?: string[];\n    render?: Function;\n    modifier?: (raw: any) => any\n    options?: ComponentCustomOptions & Record<string, any>\n    template?: string\n    mixins?: any[]\n    setup?: ComponentSetupFunction\n    methods?: MethodOptions\n}\n\nfunction buildComponent(cons: VueCons, arg: ComponentOption, extend?: any): any {\n    const option = componentOptionFactory(cons, extend)\n    const slot = obtainSlot(cons.prototype)\n    Object.keys(arg).reduce<Record<string, any>>((option, name: string) => {\n        if (['options', 'modifier', 'methods', 'emits', 'setup', 'provide'].includes(name)) {\n            return option\n        }\n        option[name] = arg[name as keyof ComponentOption]\n        return option\n    }, option)\n\n    //apply event emits\n    let emits = Array.from(slot.obtainMap('emits').keys())\n    if (Array.isArray(arg.emits)) {\n        emits = Array.from(new Set([...emits, ...arg.emits]))\n    }\n    option.emits = emits\n\n    //merge methods\n    if ('object' === typeof arg.methods && !Array.isArray(arg.methods) && arg.methods !== null) {\n        option.methods ??= {}\n        Object.assign(option.methods, arg.methods);\n    }\n\n    //merge setup function\n    if (!option.setup) {\n        option.setup = arg.setup\n    } else {\n        const oldSetup: OptionSetupFunction = option.setup\n        const newSetup: ComponentSetupFunction = arg.setup ?? function () { return {} }\n\n        const setup: ComponentSetupFunction = function (props, ctx) {\n            const newRet = newSetup(props, ctx)\n            const oldRet = oldSetup(props, ctx)\n            if (oldRet instanceof Promise || newRet instanceof Promise) {\n                return Promise.all([newRet, oldRet]).then((arr) => {\n                    return Object.assign({}, arr[0], arr[1])\n                })\n            } else {\n                return Object.assign({}, newRet, oldRet)\n            }\n        }\n\n        option.setup = setup\n    }\n\n    //merge provide function\n    const oldProvider = getProviderFunction(option.provide)\n    const newProvider = getProviderFunction(arg.provide)\n    option.provide = function () {\n        return Object.assign({}, oldProvider.call(this), newProvider.call(this))\n    }\n\n    //custom decorator\n    const map = slot.getMap('customDecorator')\n    if (map && map.size > 0) {\n        map.forEach((v) => {\n            v.forEach(ite => ite.creator.apply({}, [option, ite.key]))\n        })\n    }\n\n    //shallow merge options\n    if (arg.options) {\n        Object.assign(option, arg.options)\n    }\n\n    //apply modifier\n    if (arg.modifier) {\n        arg.modifier(option)\n    }\n\n    return defineComponent(option)\n}\nfunction build(cons: VueCons, option: ComponentOption) {\n    const slot = obtainSlot(cons.prototype)\n    slot.inComponent = true\n    const superSlot = getSuperSlot(cons.prototype)\n    if (superSlot) {\n        if (!superSlot.inComponent) {\n            throw 'Class should be decorated by Component or ComponentBase: ' + slot.master\n        }\n        if (superSlot.cachedVueComponent === null) {\n            throw 'Component decorator 1'\n        }\n    }\n    const component = buildComponent(cons, option, superSlot === null ? undefined : superSlot.cachedVueComponent)\n    component.__vfdConstructor = cons\n    slot.cachedVueComponent = component;\n    (cons as any).__vccOpts = component\n}\n\nexport const ComponentBase = optionNullableClassDecorator((cons: VueCons, option?: ComponentOption) => {\n    build(cons, option ?? {})\n})\n\nexport function toNative<T extends VueCons>(cons: T): T {\n    const slot = obtainSlot(cons.prototype)\n    if (!slot.inComponent) {\n        throw 'to native 1'\n    }\n    const cached = slot.cachedVueComponent\n    if (!cached) {\n        throw 'to native 2'\n    }\n    return cached\n}\n", "import { optionNullableMemberDecorator } from '../utils'\nimport { obtainSlot } from '../slot'\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('vanilla')\n    map.set(name, true)\n})\n", "import { obtainSlot } from '../slot'\nimport { compatibleMemberDecorator } from '../deco3/utils'\ntype Creator = { (options: any, key: string): void }\nexport interface Record {\n    key: string\n    creator: Creator\n    preserve: boolean\n}\n\nexport function createDecorator(creator: Creator, opt?: {\n    preserve?: boolean\n}) {\n    return compatibleMemberDecorator(function (proto: any, key: string) {\n        const slot = obtainSlot(proto)\n        const map = slot.obtainMap('customDecorator')\n        if(!map.has(key)){\n            map.set(key,[])\n        }\n        const arr = map.get(key)!\n        arr.push({\n            key,\n            creator,\n            preserve: !!opt?.preserve\n        })\n\n    })\n}\n\n\n", "import { ComponentBase } from './component'\nimport { obtainSlot } from './slot'\nimport type { VueCons } from './class'\nimport { Base as Vue } from './class'\n\nimport type { MergeIdentityType, IdentitySymbol } from './identity'\ntype MixedClass<Mixins extends VueCons[], Base extends VueCons = VueCons> =\n    Mixins extends [infer T extends VueCons, ...infer E extends VueCons[]] ?\n    MixedClass<E,\n        VueCons<InstanceType<Base> & InstanceType<T>,\n            MergeIdentityType<InstanceType<T>[typeof IdentitySymbol], InstanceType<Base>[typeof IdentitySymbol]>\n        >\n    > :\n    Base\nexport function mixins<T extends VueCons[]>(...conses: T) {\n    class MixinsClass extends Vue {\n    }\n\n    ComponentBase({\n        mixins: conses.map((cons => obtainSlot(cons.prototype).cachedVueComponent))\n    })(MixinsClass)\n\n    return MixinsClass as any as MixedClass<T>\n}\n\n\n\n\n", "import type { IdentityType, MergeIdentityType, IdentitySymbol } from '../identity'\nimport type { VueCons } from '../class'\n\nexport function TSX<Properties extends IdentityType['props'] = {}, Events extends IdentityType['events'] = {}, IT extends IdentityType = {\n    props: Properties\n    events: Events\n}>() {\n    return function <C extends VueCons>(cons: C): VueCons<InstanceType<C>, MergeIdentityType<IT, InstanceType<C>[typeof IdentitySymbol]>> {\n        return cons as any\n    }\n}"],
  "mappings": "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",
  "names": ["target", "map", "decorator", "cons", "build", "build", "_a", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "_a", "build", "build", "option", "decorator"]
}
