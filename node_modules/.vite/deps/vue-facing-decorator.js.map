{
  "version": 3,
  "sources": ["../../facing-metadata/src/error.ts", "../../facing-metadata/src/metadata.ts", "../../vue-facing-decorator/src/slot.ts", "../../vue-facing-decorator/src/deco3/utils.ts", "../../vue-facing-decorator/src/class.ts", "../../vue-facing-decorator/src/utils.ts", "../../vue-facing-decorator/src/option/setup.ts", "../../vue-facing-decorator/src/option/computed.ts", "../../vue-facing-decorator/src/option/data.ts", "../../vue-facing-decorator/src/option/methodsAndHooks.ts", "../../vue-facing-decorator/src/optionBuilder.ts", "../../vue-facing-decorator/src/option/ref.ts", "../../vue-facing-decorator/src/option/watch.ts", "../../vue-facing-decorator/src/option/props.ts", "../../vue-facing-decorator/src/option/inject.ts", "../../vue-facing-decorator/src/option/provide.ts", "../../vue-facing-decorator/src/option/emit.ts", "../../vue-facing-decorator/src/option/vmodel.ts", "../../vue-facing-decorator/src/option/accessor.ts", "../../vue-facing-decorator/src/component.ts", "../../vue-facing-decorator/src/option/vanilla.ts", "../../vue-facing-decorator/src/custom/custom.ts", "../../vue-facing-decorator/src/mixins.ts", "../../vue-facing-decorator/src/tsx/type.ts"],
  "sourcesContent": ["export function error(str: string): never {\r\n    throw `facing-metadata: ${str}`\r\n}", "import { error } from './error'\r\n\r\nexport class Metadata<T extends {\r\n    [index: string | number | symbol]: any\r\n}> {\r\n    symbol: symbol\r\n    /**\r\n     * Metadata.\r\n     * @param symbol Optional. Signature for this metadata. It will be set as the key in the target.\r\n     */\r\n    constructor(symbol = Symbol('faple-metadata')) {\r\n        this.symbol = symbol\r\n    }\r\n\r\n    /**\r\n     * Create metadata in the target.\r\n     * @param target Target.\r\n     * @param data   Init metadata.\r\n     */\r\n    create(target: any, data: T) {\r\n        if (Object.getOwnPropertyDescriptor(target, this.symbol)) {\r\n            error('Target had metadata')\r\n        }\r\n        Object.defineProperty(target, this.symbol, {\r\n            enumerable: false,\r\n            configurable: false,\r\n            writable: false,\r\n            value: data\r\n        })\r\n    }\r\n\r\n    #travel(target: any, traveler: { (target: any, data: T): boolean }) {\r\n        let t = target\r\n        do {\r\n            const data = this.getOwn(t)\r\n            if (data !== undefined) {\r\n                if (!traveler(target, data)) {\r\n                    break\r\n                }\r\n\r\n            }\r\n            t = Object.getPrototypeOf(t)\r\n        } while (t !== null)\r\n    }\r\n    /**\r\n     * Get own metadata.\r\n     * @param target Target.\r\n     * @returns Metadata data or undefined.\r\n     */\r\n    getOwn(target: any): T | undefined {\r\n        const des = Object.getOwnPropertyDescriptor(target, this.symbol)\r\n        if (!des) {\r\n            return undefined\r\n        }\r\n        return des.value\r\n    }\r\n    /**\r\n    * Get metadata in prototype chain.\r\n    * @param target Target.\r\n    * @returns Metadata data or undefined.\r\n    */\r\n    get(target: any): T | undefined {\r\n        let data: T | undefined = undefined\r\n        this.#travel(target, (target, _data) => {\r\n            data = _data\r\n            return false\r\n        })\r\n        return data\r\n    }\r\n    /**\r\n     * Get metadata array in prototype chain.\r\n     * @param target Target.\r\n     * @returns Metadata array to acient.\r\n     */\r\n    getAll(target: any): T[] {\r\n        let data: T[] = []\r\n        this.#travel(target, (target, _data) => {\r\n            data.push(_data)\r\n            return true\r\n        })\r\n        return data\r\n    }\r\n    /**\r\n     * Set value in the own mdatadata.\r\n     * Implement by `obtainOwn`.\r\n     * @param target Target.\r\n     * @param key Key.\r\n     * @param value value.\r\n     */\r\n    setValueOwn<K extends keyof T>(target: any, key: K, value: T[K]) {\r\n        const _data = this.getOwn(target)\r\n        if (!_data) {\r\n            error('Target has not metadata')\r\n        }\r\n        _data[key] = value\r\n    }\r\n    /**\r\n    * Set value in the recent mdatadata in prototype chain.\r\n    * Implement by `obtain`.\r\n    * @param target Target.\r\n    * @param key Key.\r\n    * @param value value.\r\n    */\r\n    setValue<K extends keyof T>(target: any, key: K, value: T[K]) {\r\n        const _data = this.get(target)\r\n        if (!_data) {\r\n            error('Target has not metadata')\r\n        }\r\n        _data[key] = value\r\n    }\r\n    /**\r\n     * Get value in the own metadata.\r\n     * @param target Target.\r\n     * @param key Key.\r\n     * @returns \r\n     */\r\n    getValueOwn<K extends keyof T>(target: any, key: K) {\r\n        const data = this.getOwn(target)\r\n        if (data === undefined) {\r\n            error('Target has not metadata')\r\n        }\r\n        return data[key]\r\n    }\r\n    /**\r\n    * Get value in the recent mdatadata WHICH HAS THE KEY in prototype chain.\r\n    * @param target Target.\r\n    * @param key Key.\r\n    */\r\n    getValue<K extends keyof T>(target: any, key: K) {\r\n        let foundMetadata = false\r\n        let value: T[K] | undefined = undefined\r\n        this.#travel(target, (target, _data) => {\r\n            foundMetadata = true\r\n            if (!(key in _data) || _data[key] === undefined) {\r\n                return true\r\n            }\r\n            value = _data[key]\r\n            return false\r\n        })\r\n        if (!foundMetadata) {\r\n            error('Target has not metadata')\r\n        }\r\n        return value as T[K]\r\n    }\r\n}\r\n", "import { Metadata } from 'facing-metadata'\r\nimport type { InjectConfig } from \"./option/inject\";\r\nimport type { EmitConfig } from \"./option/emit\";\r\nimport type { PropsConfig } from \"./option/props\";\r\nimport type { HookConfig } from \"./option/methodsAndHooks\";\r\nimport type { VModelConfig } from \"./option/vmodel\";\r\nimport type { WatchConfig } from \"./option/watch\";\r\nimport type { SetupConfig } from './option/setup'\r\nimport type { Record as CustomDecoratorRecord } from './custom/custom'\r\nimport type { RefConfig } from './option/ref';\r\nimport type { ProvideConfig } from './option/provide';\r\n\r\nconst SlotSymbol: unique symbol = Symbol('vue-facing-decorator-slot')\r\n\r\nexport type SlotMapTypes = {\r\n    vanilla: Map<string, boolean>\r\n    computed: Map<string, boolean>\r\n    provide: Map<string, ProvideConfig>\r\n    inject: Map<string, InjectConfig>\r\n    emit: Map<string, EmitConfig>\r\n    emits: Map<string, boolean>\r\n    props: Map<string, PropsConfig>\r\n    hooks: Map<string, HookConfig>\r\n    'v-model': Map<string, VModelConfig>\r\n    watch: Map<string, WatchConfig | WatchConfig[]>\r\n    ref: Map<string, RefConfig>\r\n    setup: Map<string, SetupConfig>\r\n    customDecorator: Map<string, CustomDecoratorRecord[]>\r\n}\r\n\r\nexport type SlotMapNames = keyof SlotMapTypes\r\n\r\nexport class Slot {\r\n    master: any\r\n    constructor(master: any) {\r\n        this.master = master\r\n    }\r\n    names: Map<keyof SlotMapTypes, SlotMapTypes[keyof SlotMapTypes]> = new Map()\r\n    obtainMap<T extends keyof SlotMapTypes>(name: T): SlotMapTypes[T] {\r\n        let map = this.getMap(name)\r\n        if (!map) {\r\n            map = new Map()\r\n            this.names.set(name, map)\r\n        }\r\n        return map as SlotMapTypes[T]\r\n    }\r\n    getMap<T extends keyof SlotMapTypes>(name: T) {\r\n        const map = this.names.get(name)\r\n        return map as SlotMapTypes[T] | undefined\r\n    }\r\n    inComponent = false\r\n    cachedVueComponent: any = null\r\n}\r\n\r\nconst metadata = new Metadata<Slot>(SlotSymbol)\r\n\r\nexport function makeSlot(obj: any, defaultSlot?: Slot): Slot {\r\n    if (getSlot(obj)) {\r\n        throw ''\r\n    }\r\n    if (defaultSlot) {\r\n        defaultSlot.master = obj\r\n    }\r\n    const slot = defaultSlot ?? new Slot(obj)\r\n    metadata.create(obj, slot)\r\n    return slot\r\n}\r\n\r\nexport function getSlot(obj: any): Slot | undefined {\r\n    return metadata.getOwn(obj)\r\n}\r\n\r\nexport function obtainSlot(obj: any, defaultSlot?: Slot): Slot {\r\n\r\n    const slot = getSlot(obj)\r\n    if (slot) {\r\n        return slot\r\n    }\r\n\r\n    return makeSlot(obj, defaultSlot)\r\n}", "import { VueCons } from '../class'\r\nimport { obtainSlot } from '../slot'\r\nexport const Compatible: {\r\n    fakePrototype?: any,\r\n\r\n} = {\r\n\r\n}\r\nexport function compatibleClassDecorator(deco: Function) {\r\n    return function (cons: VueCons, ctx?: ClassDecoratorContext) {\r\n        if (ctx) {//stage 3 arg is constructor, ctx is ClassDecoratorContext\r\n            if (ctx.kind !== 'class') {\r\n                throw 'deco stage 3 class'\r\n            }\r\n            const proto = Compatible.fakePrototype ??= {}\r\n            const slot = obtainSlot(proto)\r\n            delete Compatible.fakePrototype\r\n\r\n            obtainSlot(cons.prototype, slot)\r\n            const ret = deco(cons)\r\n\r\n            return ret\r\n        }\r\n        else {//stage 2 arg is constructor\r\n            return deco(cons)\r\n        }\r\n    }\r\n}\r\n\r\nexport function compatibleMemberDecorator(deco: Function) {\r\n    return function (protoOrValue: any, nameOrCtx: ClassMemberDecoratorContext | string) {\r\n        if (typeof nameOrCtx === 'object') {//stage 3 arg is value, ctx is ClassMemberDecoratorContext\r\n            const ctx = nameOrCtx\r\n            const value = protoOrValue\r\n            const proto = Compatible.fakePrototype ??= {};\r\n            proto[ctx.name!] = value\r\n            return deco(proto, ctx.name)\r\n        } else { //stage 2 arg is prototype, ctx is name stirng\r\n            const name = nameOrCtx\r\n            const proto = protoOrValue\r\n            return deco(proto, name)\r\n        }\r\n    }\r\n}", "import type { ComponentPublicInstance } from 'vue'\r\nimport type { IdentityType, Identity,IdentityAny, IdentitySymbol } from './identity'\r\nexport type VueCons<RawInstance extends Identity = Identity, IT extends IdentityType = { props: {}, events: {} }, Bundle = IT['props'] & { [index in keyof IT['events']as `on${Capitalize<index & string>}`]?: IT['events'][index] extends Function ? IT['events'][index] : { (param: IT['events'][index]): any } }> = {\r\n    new(): ComponentPublicInstance<Bundle> & Identity<IT> & Omit<RawInstance, typeof IdentitySymbol>\r\n}\r\n\r\nexport type VueConsAny<RawInstance extends Identity = Identity, IT extends IdentityType = { props: {}, events: {} }, Bundle = IT['props'] & { [index in keyof IT['events']as `on${Capitalize<index & string>}`]?: IT['events'][index] extends Function ? IT['events'][index] : { (param: IT['events'][index]): any } }> = {\r\n    new(): ComponentPublicInstance<Bundle> & IdentityAny<IT> & Omit<RawInstance, typeof IdentitySymbol> & { [index: PropertyKey]: any }\r\n}\r\n\r\nexport const Base = class {\r\n\r\n} as VueCons", "import type { IdentityAny } from './identity'\r\nimport { compatibleMemberDecorator, compatibleClassDecorator } from './deco3/utils';\r\nimport { type VueCons, Base } from './class';\r\nimport { getSlot, type Slot, type SlotMapNames } from './slot'\r\n\r\nexport function getPrototypeOf(proto: IdentityAny): IdentityAny | null {\r\n    const p = Object.getPrototypeOf(proto)\r\n    if (!(p instanceof Base)) {\r\n        return null\r\n    }\r\n    return p\r\n}\r\n\r\nexport function toComponentReverse(proto: IdentityAny) {\r\n    const arr: IdentityAny[] = []\r\n    let curr: IdentityAny | null = proto\r\n    do {\r\n        arr.unshift(curr)\r\n        curr = getPrototypeOf(curr)\r\n    } while (curr !== null && !getSlot(curr))\r\n    return arr\r\n}\r\n\r\nexport function getSuperSlot(proto: IdentityAny) {\r\n    let curr = getPrototypeOf(proto)\r\n\r\n    while (curr !== null) {\r\n        const slot = getSlot(curr)\r\n        if (slot) {\r\n            return slot\r\n        }\r\n        curr = getPrototypeOf(curr)\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * Filter decorated names\r\n */\r\nexport function filterNames(names: string[], slot: Slot, mapNames?: SlotMapNames[]) {\r\n    return names.filter(name => {\r\n        let currSlot: Slot | null = slot\r\n        while (currSlot != null) {\r\n            for (const mapName of currSlot.names.keys()) {\r\n                if (mapName === 'customDecorator') {\r\n                    const map = currSlot.obtainMap('customDecorator')\r\n                    if (map.has(name)) {\r\n                        if (map.get(name)!.every(ite => !ite.preserve)) {\r\n                            return false\r\n                        }\r\n                    }\r\n                }\r\n                if (mapNames && mapNames.includes(mapName)) {\r\n                    continue\r\n                }\r\n\r\n                const map = currSlot.names.get(mapName)!\r\n                if (map.has(name)) {\r\n                    return false\r\n                }\r\n            }\r\n            currSlot = getSuperSlot(currSlot.master)\r\n        }\r\n\r\n        return true\r\n    })\r\n}\r\n\r\n/**\r\n * Get own propertie name by a filter\r\n */\r\nexport function getValidOwnPropertyNames(obj: any, filter: (des: PropertyDescriptor, name: string) => boolean) {\r\n    const descriptors = Object.getOwnPropertyDescriptors(obj)\r\n    return Object.keys(descriptors).filter(name => filter(descriptors[name], name))\r\n}\r\n\r\n\r\n/**\r\n * Transform provide into function.\r\n */\r\nexport function getProviderFunction(provide: any): () => {} {\r\n    if (typeof provide === 'function') return provide\r\n    return function () { return provide || {} }\r\n}\r\n\r\nexport function optionNullableMemberDecorator<T>(handler: { (proto: any, name: string, option?: T): any }) {\r\n    function decorator(): any\r\n    function decorator(option: T): any//option\r\n    function decorator(proto: IdentityAny, name: any): any//deco stage 2\r\n    function decorator(value: any, ctx: ClassMemberDecoratorContext): any //deco stage 3\r\n    function decorator(optionOrProtoOrValue?: T | IdentityAny | any, nameOrCtx?: string | ClassMemberDecoratorContext): any {\r\n        if (nameOrCtx) {//no option\r\n            const protoOrValue = optionOrProtoOrValue as IdentityAny | any\r\n            compatibleMemberDecorator(function (proto: any, name: any) {\r\n                handler(proto, name)\r\n            })(protoOrValue, nameOrCtx)\r\n        }\r\n        else {//with option\r\n            const option = optionOrProtoOrValue as T\r\n            return compatibleMemberDecorator(function (proto: any, name: any) {\r\n                handler(proto, name, option as T | undefined)\r\n            })\r\n        }\r\n    }\r\n\r\n    return decorator\r\n}\r\n\r\nexport function optionNullableClassDecorator<T>(handler: { (cons: VueCons, option?: T): any }) {\r\n    function decorator(): any\r\n    function decorator(option: T): any//option\r\n    function decorator(cons: VueCons): any//deco stage 2\r\n    function decorator(cons: VueCons, ctx: ClassDecoratorContext): any//deco stage 3\r\n    function decorator(optionOrCons?: T | VueCons, ctx?: ClassDecoratorContext) {\r\n        if (typeof optionOrCons === 'function') {\r\n            const cons = optionOrCons as VueCons\r\n            compatibleClassDecorator(function (cons: VueCons) {\r\n                handler(cons)\r\n            })(cons, ctx)\r\n\r\n        } else {\r\n            const option = optionOrCons as T\r\n            return compatibleClassDecorator(function (cons: VueCons) {\r\n                handler(cons, option)\r\n            })\r\n        }\r\n    }\r\n    return decorator\r\n}\r\n\r\n", "import { compatibleMemberDecorator } from '../deco3/utils'\r\nimport type { OptionSetupFunction } from '../component'\r\nimport type { VueCons } from '../class'\r\nimport type { OptionBuilder } from '../optionBuilder'\r\nimport { obtainSlot } from '../slot'\r\n\r\nexport type SetupConfig = {\r\n    setupFunction: OptionSetupFunction\r\n}\r\n\r\nexport function decorator(setupFunction: OptionSetupFunction) {\r\n    return compatibleMemberDecorator(function (proto: any, name: string) {\r\n        const slot = obtainSlot(proto)\r\n        const map = slot.obtainMap('setup')\r\n        map.set(name, {\r\n            setupFunction\r\n        })\r\n    })\r\n}\r\n\r\nconst isPromise = (v: any): v is Promise<any> => v instanceof Promise\r\n\r\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\r\n    const slot = obtainSlot(cons.prototype)\r\n    const map = slot.getMap('setup')\r\n    if (!map || map.size === 0) {\r\n        return\r\n    }\r\n    const setup: OptionSetupFunction = function (props, ctx) {\r\n\r\n        const setupData: Record<string, any> = {};\r\n        let promises: Promise<any>[] | null = null;\r\n        for (const name of map.keys()) {\r\n\r\n            const setupState = map.get(name)!.setupFunction(props, ctx)\r\n\r\n            if (isPromise(setupState)) {\r\n                promises ??= []\r\n                promises.push(setupState.then((v) => {\r\n                    setupData[name] = v\r\n                }))\r\n            } else {\r\n                setupData[name] = setupState\r\n            }\r\n        }\r\n        if (Array.isArray(promises)) {\r\n            return Promise.all(promises).then(() => {\r\n                return setupData\r\n            })\r\n        } else {\r\n            return setupData\r\n        }\r\n    }\r\n\r\n    optionBuilder.setup = setup\r\n}\r\n", "import type { VueCons } from '../class'\r\nimport { toComponentReverse, getValidOwnPropertyNames } from '../utils'\r\nimport type { OptionBuilder } from '../optionBuilder'\r\nimport { obtainSlot } from '../slot'\r\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\r\n    optionBuilder.computed ??= {}\r\n    const slot = obtainSlot(cons.prototype)\r\n    const map = slot.obtainMap('computed')\r\n    const vanillaMap = slot.obtainMap('vanilla')\r\n    const protoArr = toComponentReverse(cons.prototype)\r\n    protoArr.forEach(proto => {\r\n        getValidOwnPropertyNames(proto, (des, name) => {\r\n            return (typeof des.get === 'function' || typeof des.set === 'function') && !vanillaMap.has(name)\r\n        }).forEach(name => {\r\n\r\n            map.set(name, true)\r\n            const des = Object.getOwnPropertyDescriptor(proto, name)!\r\n            optionBuilder.computed![name] = {\r\n                get: typeof des.get === 'function' ? des.get : undefined,\r\n                set: typeof des.set === 'function' ? des.set : undefined\r\n            }\r\n        })\r\n    })\r\n}\r\n", "import type { VueConsAny } from '../class'\r\nimport type { OptionBuilder } from '../optionBuilder'\r\nimport { filterNames, getValidOwnPropertyNames } from '../utils'\r\nimport { obtainSlot } from '../slot'\r\nexport function build(cons: VueConsAny, optionBuilder: OptionBuilder) {\r\n    optionBuilder.data ??= {}\r\n    const sample = new cons()\r\n    let names = getValidOwnPropertyNames(sample, (des, name) => {\r\n        return !!des.enumerable\r\n            && !optionBuilder.methods?.[name]\r\n            && !optionBuilder.props?.[name]\r\n    })\r\n    const slot = obtainSlot(cons.prototype)\r\n    //include these names:\r\n    //provide, user may access field directly\r\n    //customDecorator\r\n    names = filterNames(names, slot, ['provide', 'customDecorator'])\r\n    Object.assign(optionBuilder.data,\r\n        names.reduce<Record<string, any>>((pv, cv) => {\r\n            pv[cv] = sample[cv]\r\n            return pv\r\n        }, {})\r\n    )\r\n}\r\n", "import type { VueConsAny } from '../class'\r\nimport type { OptionBuilder } from '../optionBuilder'\r\nimport { toComponentReverse, filterNames, getValidOwnPropertyNames, optionNullableMemberDecorator } from '../utils'\r\nimport { obtainSlot } from '../slot'\r\nexport const HookNames: ReadonlyArray<string> = [\r\n    \"beforeCreate\",\r\n    \"created\",\r\n    \"beforeMount\",\r\n    \"mounted\",\r\n    \"beforeUpdate\",\r\n    \"updated\",\r\n    \"activated\",\r\n    \"deactivated\",\r\n    \"beforeDestroy\",\r\n    \"beforeUnmount\",\r\n    \"destroyed\",\r\n    \"unmounted\",\r\n    \"renderTracked\",\r\n    \"renderTriggered\",\r\n    \"errorCaptured\",\r\n    \"serverPrefetch\",\r\n    \"render\"\r\n] as const\r\n\r\nexport type HookConfig = null\r\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string) {\r\n    const slot = obtainSlot(proto)\r\n    const map = slot.obtainMap('hooks');\r\n    map.set(name, null)\r\n})\r\n\r\nexport function build(cons: VueConsAny, optionBuilder: OptionBuilder) {\r\n    const slot = obtainSlot(cons.prototype)\r\n    const protoArr = toComponentReverse(cons.prototype)\r\n    const map = slot.obtainMap('hooks')\r\n\r\n    optionBuilder.hooks ??= {}\r\n    optionBuilder.methods ??= {}\r\n    const HookFunctions: Record<string, Function> = {}\r\n    const MethodFunctions: Record<string, Function> = {}\r\n    protoArr.forEach(proto => {\r\n        let names = getValidOwnPropertyNames(proto, (des, name) => {\r\n            return typeof des.value === 'function' && name !== 'constructor'\r\n        })\r\n        //include these names:\r\n        //watch, user may call watch method directly\r\n        //hooks, user may call hook method directly\r\n        //emits, user may have a method name which is same as one of event names\r\n        //provide, user may access field directly\r\n        //customDecorator\r\n        names = filterNames(names, slot, ['watch', 'hooks', 'emits', 'provide', 'customDecorator']);\r\n        names.forEach(name => {\r\n            if (HookNames.includes(name) || map.has(name)) {\r\n                HookFunctions[name] = proto[name]\r\n            } else {\r\n                MethodFunctions[name] = proto[name]\r\n            }\r\n        })\r\n    })\r\n\r\n    Object.assign(optionBuilder.methods, MethodFunctions)\r\n    const beforeCreateCallbacks = [...optionBuilder.beforeCreateCallbacks ?? []]\r\n    if (beforeCreateCallbacks && beforeCreateCallbacks.length > 0) {\r\n        const oldBeforeCreateCallback = HookFunctions['beforeCreate']\r\n        HookFunctions['beforeCreate'] = function () {\r\n            beforeCreateCallbacks.forEach(callback => callback.apply(this, arguments))\r\n            if (oldBeforeCreateCallback) {\r\n                oldBeforeCreateCallback.apply(this, arguments)\r\n            }\r\n        }\r\n    }\r\n    Object.assign(optionBuilder.hooks, HookFunctions)\r\n}\r\n", "import type { WatchConfig } from './option/watch'\r\nimport type { PropsConfig } from './option/props'\r\nimport type { InjectConfig } from './option/inject'\r\nimport type { OptionSetupFunction } from './component'\r\nexport interface OptionBuilder {\r\n    name?: string\r\n    // setup?: (this: void, props: Readonly<any>, ctx: SetupContext<any>) => Promise<any> | any | RenderFunction | void\r\n    data?: Record<string, any>\r\n    methods?: Record<string, Function>\r\n    hooks?: Record<string, Function>\r\n    computed?: Record<string, any>\r\n    watch?: Record<string, WatchConfig | WatchConfig[]>\r\n    props?: Record<string, PropsConfig>\r\n    provide?: Record<string, any>\r\n    inject?: Record<string, InjectConfig>\r\n    setup?: OptionSetupFunction\r\n    beforeCreateCallbacks?: Function[]\r\n}\r\n\r\nexport function applyAccessors(optionBuilder: OptionBuilder, dataFunc: (ctx: any) => Map<string, { get: (() => any) | undefined, set: ((v: any) => any) | undefined }>) {\r\n    optionBuilder.beforeCreateCallbacks ??= []\r\n    optionBuilder.beforeCreateCallbacks.push(function (this: any) {\r\n        const ctx = this\r\n        const data = dataFunc(ctx)\r\n        data.forEach((v, n) => {\r\n            Object.defineProperty(ctx, n, v)\r\n        })\r\n    })\r\n}\r\n", "import type { VueCons } from '../class'\r\nimport { type OptionBuilder, applyAccessors } from '../optionBuilder'\r\nimport { optionNullableMemberDecorator } from '../utils'\r\nimport { obtainSlot } from '../slot'\r\nexport type RefConfig = null | string\r\n\r\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, key?: string) {\r\n    const slot = obtainSlot(proto)\r\n    const map = slot.obtainMap('ref')\r\n    map.set(name, typeof key === 'undefined' ? null : key)\r\n})\r\n\r\n\r\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\r\n    const slot = obtainSlot(cons.prototype)\r\n\r\n    const names = slot.getMap('ref')\r\n    if (!names || names.size === 0) {\r\n        return\r\n    }\r\n\r\n    applyAccessors(optionBuilder, (ctx: any) => {\r\n        const data: Map<string, { get: () => any, set: undefined }> = new Map\r\n        names.forEach((value, name) => {\r\n            const refKey = value === null ? name : value\r\n            data.set(name, {\r\n                get: function (this: any) {\r\n                    return ctx.$refs[refKey]\r\n                },\r\n                set: undefined\r\n\r\n            })\r\n        })\r\n        return data\r\n    })\r\n\r\n}\r\n", "import type { VueCons } from '../class'\r\nimport type { OptionBuilder } from '../optionBuilder'\r\nimport { obtainSlot } from '../slot'\r\nimport type { WatchCallback } from 'vue'\r\nimport { compatibleMemberDecorator } from '../deco3/utils'\r\nexport interface WatchConfig {\r\n    key: string\r\n    handler: WatchCallback,\r\n    flush?: 'post',\r\n    deep?: boolean,\r\n    immediate?: boolean,\r\n}\r\ntype Option = Omit<WatchConfig, 'handler' | 'key'>\r\nexport function decorator(key: string, option?: Option) {\r\n    return compatibleMemberDecorator(function (proto: any, name: string) {\r\n        const slot = obtainSlot(proto)\r\n        const map = slot.obtainMap('watch');\r\n        const opt = Object.assign({}, option ?? {}, {\r\n            key: key,\r\n            handler: proto[name]\r\n        })\r\n        if (map.has(name)) {\r\n            const t = map.get(name)!\r\n            if (Array.isArray(t)) {\r\n                t.push(opt)\r\n            } else {\r\n                map.set(name, [t, opt])\r\n            }\r\n        }\r\n        else {\r\n            map.set(name, opt)\r\n        }\r\n    })\r\n}\r\n\r\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\r\n    optionBuilder.watch ??= {}\r\n    const slot = obtainSlot(cons.prototype)\r\n    const names = slot.getMap('watch')\r\n    if (!names || names.size === 0) {\r\n        return\r\n    }\r\n\r\n    names.forEach((value, _name) => {\r\n        const values = Array.isArray(value) ? value : [value]\r\n        values.forEach(v => {\r\n            if (!optionBuilder.watch![v.key]) {\r\n                optionBuilder.watch![v.key] = v\r\n            } else {\r\n                const t = optionBuilder.watch![v.key]\r\n                if (Array.isArray(t)) {\r\n                    t.push(v)\r\n                } else {\r\n                    optionBuilder.watch![v.key] = [t, v]\r\n                }\r\n            }\r\n        })\r\n    })\r\n\r\n\r\n}\r\n", "import type { VueCons } from '../class'\r\nimport type { OptionBuilder } from '../optionBuilder'\r\nimport { optionNullableMemberDecorator } from '../utils'\r\nimport { obtainSlot } from '../slot'\r\nexport interface PropsConfig {\r\n    type?: any\r\n    required?: boolean\r\n    default?: any\r\n    validator?(value: any): boolean;\r\n}\r\n\r\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, option?: PropsConfig) {\r\n    const slot = obtainSlot(proto)\r\n    const map = slot.obtainMap('props')\r\n    const opt = Object.assign({}, option ?? {})\r\n    map.set(name, opt as PropsConfig)\r\n})\r\n\r\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\r\n    optionBuilder.props ??= {}\r\n    const slot = obtainSlot(cons.prototype)\r\n    const names = slot.getMap('props')\r\n    if (!names || names.size === 0) {\r\n        return\r\n    }\r\n\r\n    names.forEach((value, name) => {\r\n        optionBuilder.props![name] = value\r\n    })\r\n\r\n\r\n}\r\n\r\n\r\n", "import type { InjectionKey } from 'vue'\r\nimport type { VueCons } from '../class'\r\nimport type { OptionBuilder } from '../optionBuilder'\r\nimport { optionNullableMemberDecorator } from '../utils'\r\nimport { obtainSlot } from '../slot'\r\nexport interface InjectConfig {\r\n    from?: string | symbol | Symbol | InjectionKey<any>\r\n    default?: any\r\n}\r\n\r\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, option?: InjectConfig) {\r\n    const slot = obtainSlot(proto)\r\n    const map = slot.obtainMap('inject')\r\n    const opt = Object.assign({}, option ?? {})\r\n    map.set(name, opt)\r\n})\r\n\r\n\r\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\r\n    optionBuilder.inject ??= {}\r\n    const slot = obtainSlot(cons.prototype)\r\n    const names = slot.getMap('inject')\r\n    if (!names || names.size === 0) {\r\n        return\r\n    }\r\n\r\n    names.forEach((value, name) => {\r\n        optionBuilder.inject![name] = value\r\n    })\r\n\r\n}\r\n\r\n\r\n", "import { computed } from 'vue';\r\nimport type { VueCons } from '../class';\r\nimport type { OptionBuilder } from '../optionBuilder'\r\nimport { optionNullableMemberDecorator } from '../utils'\r\nimport { obtainSlot } from '../slot'\r\nexport type ProvideConfig = null | string\r\n\r\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, key?: ProvideConfig) {\r\n    const slot = obtainSlot(proto)\r\n    const map = slot.obtainMap('provide')\r\n    map.set(name, typeof key === 'undefined' ? null : key)\r\n})\r\n\r\nexport function build(cons: VueCons, optionBuilder: OptionBuilder, vueInstance: any) {\r\n    optionBuilder.provide ??= {}\r\n    const slot = obtainSlot(cons.prototype)\r\n    const names = slot.obtainMap('provide')\r\n    if (!names) return null\r\n    names.forEach((value, name) => {\r\n        const key = value === null ? name : value\r\n        optionBuilder.provide![key] = computed(() => vueInstance[name])\r\n    })\r\n}\r\n", "import type { VueCons } from '../class'\r\nimport type { OptionBuilder } from '../optionBuilder'\r\nimport { optionNullableMemberDecorator } from '../utils'\r\nexport type EmitConfig = null | string\r\nimport { obtainSlot } from '../slot'\r\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, key?: string) {\r\n    const slot = obtainSlot(proto)\r\n    const map = slot.obtainMap('emit');\r\n    map.set(name, typeof key === 'undefined' ? null : key)\r\n})\r\n\r\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\r\n    optionBuilder.methods ??= {}\r\n    const proto = cons.prototype\r\n    const slot = obtainSlot(proto)\r\n    const names = slot.getMap('emit')\r\n    if (!names || names.size === 0) {\r\n        return\r\n    }\r\n    const emits = slot.obtainMap('emits')\r\n    names.forEach((value, key) => {\r\n        const eventName = value === null ? key : value\r\n        emits.set(eventName, true)\r\n        optionBuilder.methods![key] = async function (this: any) {\r\n\r\n            const ret = proto[key].apply(this, arguments)\r\n            if (ret instanceof Promise) {\r\n                const proRet = await ret\r\n                this.$emit(eventName, proRet)\r\n            }\r\n            else if (ret === undefined) {\r\n                this.$emit(eventName)\r\n            } else {\r\n                this.$emit(eventName, ret)\r\n            }\r\n        }\r\n    })\r\n\r\n}\r\n", "import type { VueCons } from '../class'\r\nimport type { OptionBuilder } from '../optionBuilder'\r\nimport {  optionNullableMemberDecorator } from '../utils'\r\nimport { decorator as PropsDecorator, type PropsConfig } from './props'\r\nimport { obtainSlot } from '../slot'\r\nexport type VModelConfig = PropsConfig & {\r\n    name?: string\r\n}\r\n\r\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, option?: VModelConfig) {\r\n    option ??= {}\r\n    const slot = obtainSlot(proto)\r\n    let vmodelName = 'modelValue'\r\n    const propsConfig = { ...option }\r\n    if (propsConfig) {\r\n        vmodelName = propsConfig.name ?? vmodelName\r\n        delete propsConfig.name\r\n    }\r\n    PropsDecorator(propsConfig)(proto, vmodelName)\r\n    const map = slot.obtainMap('v-model')\r\n    map.set(name, option)\r\n})\r\n\r\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\r\n    optionBuilder.computed ??= {}\r\n    const slot = obtainSlot(cons.prototype)\r\n    const names = slot.getMap('v-model')\r\n    if (!names || names.size === 0) {\r\n        return\r\n    }\r\n    const emits = slot.obtainMap('emits')\r\n\r\n    names.forEach((value, name) => {\r\n        const vmodelName = (value && value.name) ?? 'modelValue'\r\n        const eventName = `update:${vmodelName}`\r\n        optionBuilder.computed![name] = {\r\n            get: function (this: any) {\r\n                return this[vmodelName]\r\n            },\r\n            set: function (val: any) {\r\n                this.$emit(eventName, val)\r\n            }\r\n        }\r\n        emits.set(eventName, true)\r\n    })\r\n\r\n}\r\n", "import type { VueCons } from '../class'\r\nimport { type OptionBuilder, applyAccessors } from '../optionBuilder'\r\nimport { toComponentReverse } from '../utils'\r\nimport { obtainSlot } from '../slot'\r\nexport function build(cons: VueCons, optionBuilder: OptionBuilder) {\r\n    const slot = obtainSlot(cons.prototype)\r\n    const vanillaMap = slot.getMap('vanilla')\r\n    if (!vanillaMap || vanillaMap.size === 0) {\r\n        return\r\n    }\r\n    const protoArr = toComponentReverse(cons.prototype)\r\n    const map: Map<string, { get: (() => any) | undefined, set: ((v: any) => any) | undefined }> | undefined = new Map\r\n\r\n    applyAccessors(optionBuilder, (ctx: any) => {\r\n        protoArr.forEach(proto => {\r\n            const deses = Object.getOwnPropertyDescriptors(proto)\r\n            for (const name in deses) {\r\n                const des = deses[name]\r\n                if (des && vanillaMap.has(name)) {\r\n                    if (typeof des.get === 'function' || typeof des.set === 'function') {\r\n                        map.set(name, {\r\n                            set: typeof des.set === 'function' ? des.set.bind(ctx) : undefined,\r\n                            get: typeof des.get === 'function' ? des.get.bind(ctx) : undefined,\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        })\r\n        return map\r\n    })\r\n}\r\n", "import { defineComponent, type ComponentCustomOptions, type MethodOptions } from 'vue';\r\nimport { obtainSlot } from './slot'\r\nimport { getSuperSlot, getProviderFunction, optionNullableClassDecorator } from './utils'\r\nimport { build as optionSetup } from './option/setup'\r\nimport { build as optionComputed } from './option/computed'\r\nimport { build as optionData } from './option/data'\r\nimport { build as optionMethodsAndHooks } from './option/methodsAndHooks'\r\nimport { build as optionRef } from './option/ref'\r\nimport { build as optionWatch } from './option/watch'\r\nimport { build as optionProps } from './option/props'\r\nimport { build as optionInject } from './option/inject'\r\nimport { build as optionProvide } from './option/provide'\r\nimport { build as optionEmit } from './option/emit'\r\nimport { build as optionVModel } from './option/vmodel'\r\nimport { build as optionAccessor } from './option/accessor'\r\nimport type { SetupContext } from 'vue';\r\nimport type { OptionBuilder } from './optionBuilder'\r\nimport type { VueCons } from './class'\r\ntype SetupFunction<T> = (this: void, props: Readonly<any>, ctx: SetupContext<any>) => T | Promise<T>\r\nexport type OptionSetupFunction = SetupFunction<any>\r\nexport type ComponentSetupFunction = SetupFunction<Record<string, any>>\r\nfunction componentOptionFactory(cons: VueCons, extend?: any) {\r\n    const optionBuilder: OptionBuilder = {}\r\n    optionSetup(cons, optionBuilder)\r\n    optionVModel(cons, optionBuilder)\r\n    optionComputed(cons, optionBuilder)//after VModel\r\n    optionWatch(cons, optionBuilder)\r\n    optionProps(cons, optionBuilder)\r\n    optionInject(cons, optionBuilder)\r\n    optionEmit(cons, optionBuilder)\r\n    optionRef(cons, optionBuilder)//after Computed\r\n    optionAccessor(cons, optionBuilder)\r\n    optionMethodsAndHooks(cons, optionBuilder)//the last one\r\n    const raw = {\r\n        name: cons.name,\r\n        setup: optionBuilder.setup,\r\n        data() {\r\n            delete optionBuilder.data\r\n            optionData(cons, optionBuilder)\r\n            return optionBuilder.data ?? {}\r\n        },\r\n        methods: optionBuilder.methods,\r\n        computed: optionBuilder.computed,\r\n        watch: optionBuilder.watch,\r\n        props: optionBuilder.props,\r\n        inject: optionBuilder.inject,\r\n        provide() {\r\n            optionProvide(cons, optionBuilder, this)\r\n            return optionBuilder.provide ?? {}\r\n        },\r\n        ...optionBuilder.hooks,\r\n        extends: extend\r\n    }\r\n    return raw as any\r\n}\r\n\r\ntype ComponentOption = {\r\n    name?: string\r\n    emits?: string[]\r\n    provide?: Record<string, any> | Function\r\n    components?: Record<string, any>\r\n    directives?: Record<string, any>;\r\n    inheritAttrs?: boolean;\r\n    expose?: string[];\r\n    render?: Function;\r\n    modifier?: (raw: any) => any\r\n    options?: ComponentCustomOptions & Record<string, any>\r\n    template?: string\r\n    mixins?: any[]\r\n    setup?: ComponentSetupFunction\r\n    methods?: MethodOptions\r\n}\r\n\r\nfunction buildComponent(cons: VueCons, arg: ComponentOption, extend?: any): any {\r\n    const option = componentOptionFactory(cons, extend)\r\n    const slot = obtainSlot(cons.prototype)\r\n    Object.keys(arg).reduce<Record<string, any>>((option, name: string) => {\r\n        if (['options', 'modifier', 'methods', 'emits', 'setup', 'provide'].includes(name)) {\r\n            return option\r\n        }\r\n        option[name] = arg[name as keyof ComponentOption]\r\n        return option\r\n    }, option)\r\n\r\n    //apply event emits\r\n    let emits = Array.from(slot.obtainMap('emits').keys())\r\n    if (Array.isArray(arg.emits)) {\r\n        emits = Array.from(new Set([...emits, ...arg.emits]))\r\n    }\r\n    option.emits = emits\r\n\r\n    //merge methods\r\n    if ('object' === typeof arg.methods && !Array.isArray(arg.methods) && arg.methods !== null) {\r\n        option.methods ??= {}\r\n        Object.assign(option.methods, arg.methods);\r\n    }\r\n\r\n    //merge setup function\r\n    if (!option.setup) {\r\n        option.setup = arg.setup\r\n    } else {\r\n        const oldSetup: OptionSetupFunction = option.setup\r\n        const newSetup: ComponentSetupFunction = arg.setup ?? function () { return {} }\r\n\r\n        const setup: ComponentSetupFunction = function (props, ctx) {\r\n            const newRet = newSetup(props, ctx)\r\n            const oldRet = oldSetup(props, ctx)\r\n            if (oldRet instanceof Promise || newRet instanceof Promise) {\r\n                return Promise.all([newRet, oldRet]).then((arr) => {\r\n                    return Object.assign({}, arr[0], arr[1])\r\n                })\r\n            } else {\r\n                return Object.assign({}, newRet, oldRet)\r\n            }\r\n        }\r\n\r\n        option.setup = setup\r\n    }\r\n\r\n    //merge provide function\r\n    const oldProvider = getProviderFunction(option.provide)\r\n    const newProvider = getProviderFunction(arg.provide)\r\n    option.provide = function () {\r\n        return Object.assign({}, oldProvider.call(this), newProvider.call(this))\r\n    }\r\n\r\n    //custom decorator\r\n    const map = slot.getMap('customDecorator')\r\n    if (map && map.size > 0) {\r\n        map.forEach((v) => {\r\n            v.forEach(ite => ite.creator.apply({}, [option, ite.key]))\r\n        })\r\n    }\r\n\r\n    //shallow merge options\r\n    if (arg.options) {\r\n        Object.assign(option, arg.options)\r\n    }\r\n\r\n    //apply modifier\r\n    if (arg.modifier) {\r\n        arg.modifier(option)\r\n    }\r\n\r\n    return defineComponent(option)\r\n}\r\nfunction build(cons: VueCons, option: ComponentOption) {\r\n    const slot = obtainSlot(cons.prototype)\r\n    slot.inComponent = true\r\n    const superSlot = getSuperSlot(cons.prototype)\r\n    if (superSlot) {\r\n        if (!superSlot.inComponent) {\r\n            throw 'Class should be decorated by Component or ComponentBase: ' + slot.master\r\n        }\r\n        if (superSlot.cachedVueComponent === null) {\r\n            throw 'Component decorator 1'\r\n        }\r\n    }\r\n    const component = buildComponent(cons, option, superSlot === null ? undefined : superSlot.cachedVueComponent)\r\n    component.__vfdConstructor = cons\r\n    slot.cachedVueComponent = component;\r\n    (cons as any).__vccOpts = component\r\n}\r\n\r\nexport const ComponentBase = optionNullableClassDecorator((cons: VueCons, option?: ComponentOption) => {\r\n    build(cons, option ?? {})\r\n})\r\n\r\nexport function toNative<T extends VueCons>(cons: T): T {\r\n    const slot = obtainSlot(cons.prototype)\r\n    if (!slot.inComponent) {\r\n        throw 'to native 1'\r\n    }\r\n    const cached = slot.cachedVueComponent\r\n    if (!cached) {\r\n        throw 'to native 2'\r\n    }\r\n    return cached\r\n}\r\n", "import { optionNullableMemberDecorator } from '../utils'\r\nimport { obtainSlot } from '../slot'\r\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string) {\r\n    const slot = obtainSlot(proto)\r\n    const map = slot.obtainMap('vanilla')\r\n    map.set(name, true)\r\n})\r\n", "import { obtainSlot } from '../slot'\r\nimport { compatibleMemberDecorator } from '../deco3/utils'\r\ntype Creator = { (options: any, key: string): void }\r\nexport interface Record {\r\n    key: string\r\n    creator: Creator\r\n    preserve: boolean\r\n}\r\n\r\nexport function createDecorator(creator: Creator, opt?: {\r\n    preserve?: boolean\r\n}) {\r\n    return compatibleMemberDecorator(function (proto: any, key: string) {\r\n        const slot = obtainSlot(proto)\r\n        const map = slot.obtainMap('customDecorator')\r\n        if(!map.has(key)){\r\n            map.set(key,[])\r\n        }\r\n        const arr = map.get(key)!\r\n        arr.push({\r\n            key,\r\n            creator,\r\n            preserve: !!opt?.preserve\r\n        })\r\n\r\n    })\r\n}\r\n\r\n\r\n", "import { ComponentBase } from './component'\r\nimport { obtainSlot } from './slot'\r\nimport type { VueCons } from './class'\r\nimport { Base as Vue } from './class'\r\n\r\nimport type { MergeIdentityType, IdentitySymbol } from './identity'\r\ntype MixedClass<Mixins extends VueCons[], Base extends VueCons = VueCons> =\r\n    Mixins extends [infer T extends VueCons, ...infer E extends VueCons[]] ?\r\n    MixedClass<E,\r\n        VueCons<InstanceType<Base> & InstanceType<T>,\r\n            MergeIdentityType<InstanceType<T>[typeof IdentitySymbol], InstanceType<Base>[typeof IdentitySymbol]>\r\n        >\r\n    > :\r\n    Base\r\nexport function mixins<T extends VueCons[]>(...conses: T) {\r\n    class MixinsClass extends Vue {\r\n    }\r\n\r\n    ComponentBase({\r\n        mixins: conses.map((cons => obtainSlot(cons.prototype).cachedVueComponent))\r\n    })(MixinsClass)\r\n\r\n    return MixinsClass as any as MixedClass<T>\r\n}\r\n\r\n\r\n\r\n\r\n", "import type { IdentityType, MergeIdentityType, IdentitySymbol } from '../identity'\r\nimport type { VueCons } from '../class'\r\n\r\nexport function TSX<Properties extends IdentityType['props'] = {}, Events extends IdentityType['events'] = {}, IT extends IdentityType = {\r\n    props: Properties\r\n    events: Events\r\n}>() {\r\n    return function <C extends VueCons>(cons: C): VueCons<InstanceType<C>, MergeIdentityType<IT, InstanceType<C>[typeof IdentitySymbol]>> {\r\n        return cons as any\r\n    }\r\n}"],
  "mappings": "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",
  "names": ["target", "map", "decorator", "cons", "build", "build", "_a", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "_a", "build", "build", "option", "decorator"]
}
